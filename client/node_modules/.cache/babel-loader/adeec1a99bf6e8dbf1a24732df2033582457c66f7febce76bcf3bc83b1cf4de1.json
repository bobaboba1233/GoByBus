{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  compileNonPath: null,\n  matchHas: null,\n  parseDestination: null,\n  prepareDestination: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  compileNonPath: function () {\n    return compileNonPath;\n  },\n  matchHas: function () {\n    return matchHas;\n  },\n  parseDestination: function () {\n    return parseDestination;\n  },\n  prepareDestination: function () {\n    return prepareDestination;\n  }\n});\nconst _pathtoregexp = require(\"next/dist/compiled/path-to-regexp\");\nconst _escaperegexp = require(\"../../escape-regexp\");\nconst _parseurl = require(\"./parse-url\");\nconst _interceptionroutes = require(\"./interception-routes\");\nconst _approuterheaders = require(\"../../../../client/components/app-router-headers\");\nconst _getcookieparser = require(\"../../../../server/api-utils/get-cookie-parser\");\n/**\n * Ensure only a-zA-Z are used for param names for proper interpolating\n * with path-to-regexp\n */\nfunction getSafeParamName(paramName) {\n  let newParamName = '';\n  for (let i = 0; i < paramName.length; i++) {\n    const charCode = paramName.charCodeAt(i);\n    if (charCode > 64 && charCode < 91 ||\n    // A-Z\n    charCode > 96 && charCode < 123 // a-z\n    ) {\n      newParamName += paramName[i];\n    }\n  }\n  return newParamName;\n}\nfunction escapeSegment(str, segmentName) {\n  return str.replace(new RegExp(\":\" + (0, _escaperegexp.escapeStringRegexp)(segmentName), 'g'), \"__ESC_COLON_\" + segmentName);\n}\nfunction unescapeSegments(str) {\n  return str.replace(/__ESC_COLON_/gi, ':');\n}\nfunction matchHas(req, query, has, missing) {\n  if (has === void 0) has = [];\n  if (missing === void 0) missing = [];\n  const params = {};\n  const hasMatch = hasItem => {\n    let value;\n    let key = hasItem.key;\n    switch (hasItem.type) {\n      case 'header':\n        {\n          key = key.toLowerCase();\n          value = req.headers[key];\n          break;\n        }\n      case 'cookie':\n        {\n          if ('cookies' in req) {\n            value = req.cookies[hasItem.key];\n          } else {\n            const cookies = (0, _getcookieparser.getCookieParser)(req.headers)();\n            value = cookies[hasItem.key];\n          }\n          break;\n        }\n      case 'query':\n        {\n          value = query[key];\n          break;\n        }\n      case 'host':\n        {\n          const {\n            host\n          } = (req == null ? void 0 : req.headers) || {};\n          // remove port from host if present\n          const hostname = host == null ? void 0 : host.split(':', 1)[0].toLowerCase();\n          value = hostname;\n          break;\n        }\n      default:\n        {\n          break;\n        }\n    }\n    if (!hasItem.value && value) {\n      params[getSafeParamName(key)] = value;\n      return true;\n    } else if (value) {\n      const matcher = new RegExp(\"^\" + hasItem.value + \"$\");\n      const matches = Array.isArray(value) ? value.slice(-1)[0].match(matcher) : value.match(matcher);\n      if (matches) {\n        if (Array.isArray(matches)) {\n          if (matches.groups) {\n            Object.keys(matches.groups).forEach(groupKey => {\n              params[groupKey] = matches.groups[groupKey];\n            });\n          } else if (hasItem.type === 'host' && matches[0]) {\n            params.host = matches[0];\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  };\n  const allMatch = has.every(item => hasMatch(item)) && !missing.some(item => hasMatch(item));\n  if (allMatch) {\n    return params;\n  }\n  return false;\n}\nfunction compileNonPath(value, params) {\n  if (!value.includes(':')) {\n    return value;\n  }\n  for (const key of Object.keys(params)) {\n    if (value.includes(\":\" + key)) {\n      value = value.replace(new RegExp(\":\" + key + \"\\\\*\", 'g'), \":\" + key + \"--ESCAPED_PARAM_ASTERISKS\").replace(new RegExp(\":\" + key + \"\\\\?\", 'g'), \":\" + key + \"--ESCAPED_PARAM_QUESTION\").replace(new RegExp(\":\" + key + \"\\\\+\", 'g'), \":\" + key + \"--ESCAPED_PARAM_PLUS\").replace(new RegExp(\":\" + key + \"(?!\\\\w)\", 'g'), \"--ESCAPED_PARAM_COLON\" + key);\n    }\n  }\n  value = value.replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*');\n  // the value needs to start with a forward-slash to be compiled\n  // correctly\n  return (0, _pathtoregexp.compile)(\"/\" + value, {\n    validate: false\n  })(params).slice(1);\n}\nfunction parseDestination(args) {\n  let escaped = args.destination;\n  for (const param of Object.keys({\n    ...args.params,\n    ...args.query\n  })) {\n    if (!param) continue;\n    escaped = escapeSegment(escaped, param);\n  }\n  const parsed = (0, _parseurl.parseUrl)(escaped);\n  let pathname = parsed.pathname;\n  if (pathname) {\n    pathname = unescapeSegments(pathname);\n  }\n  let href = parsed.href;\n  if (href) {\n    href = unescapeSegments(href);\n  }\n  let hostname = parsed.hostname;\n  if (hostname) {\n    hostname = unescapeSegments(hostname);\n  }\n  let hash = parsed.hash;\n  if (hash) {\n    hash = unescapeSegments(hash);\n  }\n  return {\n    ...parsed,\n    pathname,\n    hostname,\n    href,\n    hash\n  };\n}\nfunction prepareDestination(args) {\n  const query = Object.assign({}, args.query);\n  delete query[_approuterheaders.NEXT_RSC_UNION_QUERY];\n  const parsedDestination = parseDestination(args);\n  const {\n    hostname: destHostname,\n    query: destQuery\n  } = parsedDestination;\n  // The following code assumes that the pathname here includes the hash if it's\n  // present.\n  let destPath = parsedDestination.pathname;\n  if (parsedDestination.hash) {\n    destPath = \"\" + destPath + parsedDestination.hash;\n  }\n  const destParams = [];\n  const destPathParamKeys = [];\n  (0, _pathtoregexp.pathToRegexp)(destPath, destPathParamKeys);\n  for (const key of destPathParamKeys) {\n    destParams.push(key.name);\n  }\n  if (destHostname) {\n    const destHostnameParamKeys = [];\n    (0, _pathtoregexp.pathToRegexp)(destHostname, destHostnameParamKeys);\n    for (const key of destHostnameParamKeys) {\n      destParams.push(key.name);\n    }\n  }\n  const destPathCompiler = (0, _pathtoregexp.compile)(destPath,\n  // we don't validate while compiling the destination since we should\n  // have already validated before we got to this point and validating\n  // breaks compiling destinations with named pattern params from the source\n  // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n  // since compile validation is meant for reversing and not for inserting\n  // params from a separate path-regex into another\n  {\n    validate: false\n  });\n  let destHostnameCompiler;\n  if (destHostname) {\n    destHostnameCompiler = (0, _pathtoregexp.compile)(destHostname, {\n      validate: false\n    });\n  }\n  // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    // the value needs to start with a forward-slash to be compiled\n    // correctly\n    if (Array.isArray(strOrArray)) {\n      destQuery[key] = strOrArray.map(value => compileNonPath(unescapeSegments(value), args.params));\n    } else if (typeof strOrArray === 'string') {\n      destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params);\n    }\n  }\n  // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  let paramKeys = Object.keys(args.params).filter(name => name !== 'nextInternalLocale');\n  if (args.appendParamsToQuery && !paramKeys.some(key => destParams.includes(key))) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = args.params[key];\n      }\n    }\n  }\n  let newUrl;\n  // The compiler also that the interception route marker is an unnamed param, hence '0',\n  // so we need to add it to the params object.\n  if ((0, _interceptionroutes.isInterceptionRouteAppPath)(destPath)) {\n    for (const segment of destPath.split('/')) {\n      const marker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find(m => segment.startsWith(m));\n      if (marker) {\n        if (marker === '(..)(..)') {\n          args.params['0'] = '(..)';\n          args.params['1'] = '(..)';\n        } else {\n          args.params['0'] = marker;\n        }\n        break;\n      }\n    }\n  }\n  try {\n    newUrl = destPathCompiler(args.params);\n    const [pathname, hash] = newUrl.split('#', 2);\n    if (destHostnameCompiler) {\n      parsedDestination.hostname = destHostnameCompiler(args.params);\n    }\n    parsedDestination.pathname = pathname;\n    parsedDestination.hash = \"\" + (hash ? '#' : '') + (hash || '');\n    delete parsedDestination.search;\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw Object.defineProperty(new Error(\"To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match\"), \"__NEXT_ERROR_CODE\", {\n        value: \"E329\",\n        enumerable: false,\n        configurable: true\n      });\n    }\n    throw err;\n  }\n  // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = {\n    ...query,\n    ...parsedDestination.query\n  };\n  return {\n    newUrl,\n    destQuery,\n    parsedDestination\n  };\n}","map":{"version":3,"names":["compileNonPath","matchHas","parseDestination","prepareDestination","getSafeParamName","paramName","newParamName","i","length","charCode","charCodeAt","escapeSegment","str","segmentName","replace","RegExp","_escaperegexp","escapeStringRegexp","unescapeSegments","req","query","has","missing","params","hasMatch","hasItem","value","key","type","toLowerCase","headers","cookies","_getcookieparser","getCookieParser","host","hostname","split","matcher","matches","Array","isArray","slice","match","groups","Object","keys","forEach","groupKey","allMatch","every","item","some","includes","_pathtoregexp","compile","validate","args","escaped","destination","param","parsed","_parseurl","parseUrl","pathname","href","hash","assign","_approuterheaders","NEXT_RSC_UNION_QUERY","parsedDestination","destHostname","destQuery","destPath","destParams","destPathParamKeys","pathToRegexp","push","name","destHostnameParamKeys","destPathCompiler","destHostnameCompiler","strOrArray","entries","map","paramKeys","filter","appendParamsToQuery","newUrl","_interceptionroutes","isInterceptionRouteAppPath","segment","marker","INTERCEPTION_ROUTE_MARKERS","find","m","startsWith","search","err","message","defineProperty","Error"],"sources":["C:\\Users\\богдан\\Desktop\\gobybus\\client\\node_modules\\next\\src\\shared\\lib\\router\\utils\\prepare-destination.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { Key } from 'next/dist/compiled/path-to-regexp'\nimport type { NextParsedUrlQuery } from '../../../../server/request-meta'\nimport type { RouteHas } from '../../../../lib/load-custom-routes'\nimport type { BaseNextRequest } from '../../../../server/base-http'\n\nimport { compile, pathToRegexp } from 'next/dist/compiled/path-to-regexp'\nimport { escapeStringRegexp } from '../../escape-regexp'\nimport { parseUrl } from './parse-url'\nimport {\n  INTERCEPTION_ROUTE_MARKERS,\n  isInterceptionRouteAppPath,\n} from './interception-routes'\nimport { NEXT_RSC_UNION_QUERY } from '../../../../client/components/app-router-headers'\nimport { getCookieParser } from '../../../../server/api-utils/get-cookie-parser'\nimport type { Params } from '../../../../server/request/params'\n\n/**\n * Ensure only a-zA-Z are used for param names for proper interpolating\n * with path-to-regexp\n */\nfunction getSafeParamName(paramName: string) {\n  let newParamName = ''\n\n  for (let i = 0; i < paramName.length; i++) {\n    const charCode = paramName.charCodeAt(i)\n\n    if (\n      (charCode > 64 && charCode < 91) || // A-Z\n      (charCode > 96 && charCode < 123) // a-z\n    ) {\n      newParamName += paramName[i]\n    }\n  }\n  return newParamName\n}\n\nfunction escapeSegment(str: string, segmentName: string) {\n  return str.replace(\n    new RegExp(`:${escapeStringRegexp(segmentName)}`, 'g'),\n    `__ESC_COLON_${segmentName}`\n  )\n}\n\nfunction unescapeSegments(str: string) {\n  return str.replace(/__ESC_COLON_/gi, ':')\n}\n\nexport function matchHas(\n  req: BaseNextRequest | IncomingMessage,\n  query: Params,\n  has: RouteHas[] = [],\n  missing: RouteHas[] = []\n): false | Params {\n  const params: Params = {}\n\n  const hasMatch = (hasItem: RouteHas) => {\n    let value\n    let key = hasItem.key\n\n    switch (hasItem.type) {\n      case 'header': {\n        key = key!.toLowerCase()\n        value = req.headers[key] as string\n        break\n      }\n      case 'cookie': {\n        if ('cookies' in req) {\n          value = req.cookies[hasItem.key]\n        } else {\n          const cookies = getCookieParser(req.headers)()\n          value = cookies[hasItem.key]\n        }\n\n        break\n      }\n      case 'query': {\n        value = query[key!]\n        break\n      }\n      case 'host': {\n        const { host } = req?.headers || {}\n        // remove port from host if present\n        const hostname = host?.split(':', 1)[0].toLowerCase()\n        value = hostname\n        break\n      }\n      default: {\n        break\n      }\n    }\n\n    if (!hasItem.value && value) {\n      params[getSafeParamName(key!)] = value\n      return true\n    } else if (value) {\n      const matcher = new RegExp(`^${hasItem.value}$`)\n      const matches = Array.isArray(value)\n        ? value.slice(-1)[0].match(matcher)\n        : value.match(matcher)\n\n      if (matches) {\n        if (Array.isArray(matches)) {\n          if (matches.groups) {\n            Object.keys(matches.groups).forEach((groupKey) => {\n              params[groupKey] = matches.groups![groupKey]\n            })\n          } else if (hasItem.type === 'host' && matches[0]) {\n            params.host = matches[0]\n          }\n        }\n        return true\n      }\n    }\n    return false\n  }\n\n  const allMatch =\n    has.every((item) => hasMatch(item)) &&\n    !missing.some((item) => hasMatch(item))\n\n  if (allMatch) {\n    return params\n  }\n  return false\n}\n\nexport function compileNonPath(value: string, params: Params): string {\n  if (!value.includes(':')) {\n    return value\n  }\n\n  for (const key of Object.keys(params)) {\n    if (value.includes(`:${key}`)) {\n      value = value\n        .replace(\n          new RegExp(`:${key}\\\\*`, 'g'),\n          `:${key}--ESCAPED_PARAM_ASTERISKS`\n        )\n        .replace(\n          new RegExp(`:${key}\\\\?`, 'g'),\n          `:${key}--ESCAPED_PARAM_QUESTION`\n        )\n        .replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`)\n        .replace(\n          new RegExp(`:${key}(?!\\\\w)`, 'g'),\n          `--ESCAPED_PARAM_COLON${key}`\n        )\n    }\n  }\n  value = value\n    .replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1')\n    .replace(/--ESCAPED_PARAM_PLUS/g, '+')\n    .replace(/--ESCAPED_PARAM_COLON/g, ':')\n    .replace(/--ESCAPED_PARAM_QUESTION/g, '?')\n    .replace(/--ESCAPED_PARAM_ASTERISKS/g, '*')\n\n  // the value needs to start with a forward-slash to be compiled\n  // correctly\n  return compile(`/${value}`, { validate: false })(params).slice(1)\n}\n\nexport function parseDestination(args: {\n  destination: string\n  params: Readonly<Params>\n  query: Readonly<NextParsedUrlQuery>\n}) {\n  let escaped = args.destination\n  for (const param of Object.keys({ ...args.params, ...args.query })) {\n    if (!param) continue\n\n    escaped = escapeSegment(escaped, param)\n  }\n\n  const parsed = parseUrl(escaped)\n\n  let pathname = parsed.pathname\n  if (pathname) {\n    pathname = unescapeSegments(pathname)\n  }\n\n  let href = parsed.href\n  if (href) {\n    href = unescapeSegments(href)\n  }\n\n  let hostname = parsed.hostname\n  if (hostname) {\n    hostname = unescapeSegments(hostname)\n  }\n\n  let hash = parsed.hash\n  if (hash) {\n    hash = unescapeSegments(hash)\n  }\n\n  return {\n    ...parsed,\n    pathname,\n    hostname,\n    href,\n    hash,\n  }\n}\n\nexport function prepareDestination(args: {\n  appendParamsToQuery: boolean\n  destination: string\n  params: Params\n  query: NextParsedUrlQuery\n}) {\n  const query = Object.assign({}, args.query)\n  delete query[NEXT_RSC_UNION_QUERY]\n\n  const parsedDestination = parseDestination(args)\n\n  const { hostname: destHostname, query: destQuery } = parsedDestination\n\n  // The following code assumes that the pathname here includes the hash if it's\n  // present.\n  let destPath = parsedDestination.pathname\n  if (parsedDestination.hash) {\n    destPath = `${destPath}${parsedDestination.hash}`\n  }\n\n  const destParams: (string | number)[] = []\n\n  const destPathParamKeys: Key[] = []\n  pathToRegexp(destPath, destPathParamKeys)\n  for (const key of destPathParamKeys) {\n    destParams.push(key.name)\n  }\n\n  if (destHostname) {\n    const destHostnameParamKeys: Key[] = []\n    pathToRegexp(destHostname, destHostnameParamKeys)\n    for (const key of destHostnameParamKeys) {\n      destParams.push(key.name)\n    }\n  }\n\n  const destPathCompiler = compile(\n    destPath,\n    // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    { validate: false }\n  )\n\n  let destHostnameCompiler\n  if (destHostname) {\n    destHostnameCompiler = compile(destHostname, { validate: false })\n  }\n\n  // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    // the value needs to start with a forward-slash to be compiled\n    // correctly\n    if (Array.isArray(strOrArray)) {\n      destQuery[key] = strOrArray.map((value) =>\n        compileNonPath(unescapeSegments(value), args.params)\n      )\n    } else if (typeof strOrArray === 'string') {\n      destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params)\n    }\n  }\n\n  // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  let paramKeys = Object.keys(args.params).filter(\n    (name) => name !== 'nextInternalLocale'\n  )\n\n  if (\n    args.appendParamsToQuery &&\n    !paramKeys.some((key) => destParams.includes(key))\n  ) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = args.params[key]\n      }\n    }\n  }\n\n  let newUrl\n\n  // The compiler also that the interception route marker is an unnamed param, hence '0',\n  // so we need to add it to the params object.\n  if (isInterceptionRouteAppPath(destPath)) {\n    for (const segment of destPath.split('/')) {\n      const marker = INTERCEPTION_ROUTE_MARKERS.find((m) =>\n        segment.startsWith(m)\n      )\n      if (marker) {\n        if (marker === '(..)(..)') {\n          args.params['0'] = '(..)'\n          args.params['1'] = '(..)'\n        } else {\n          args.params['0'] = marker\n        }\n        break\n      }\n    }\n  }\n\n  try {\n    newUrl = destPathCompiler(args.params)\n\n    const [pathname, hash] = newUrl.split('#', 2)\n    if (destHostnameCompiler) {\n      parsedDestination.hostname = destHostnameCompiler(args.params)\n    }\n    parsedDestination.pathname = pathname\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`\n    delete (parsedDestination as any).search\n  } catch (err: any) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\n        `To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`\n      )\n    }\n    throw err\n  }\n\n  // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = {\n    ...query,\n    ...parsedDestination.query,\n  }\n\n  return {\n    newUrl,\n    destQuery,\n    parsedDestination,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}