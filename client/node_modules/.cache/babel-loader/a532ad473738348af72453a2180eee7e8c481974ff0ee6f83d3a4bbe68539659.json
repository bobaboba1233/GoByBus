{"ast":null,"code":"// tslint:disable:no-console\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  createKey: null,\n  default: null,\n  matchesMiddleware: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  createKey: function () {\n    return createKey;\n  },\n  default: function () {\n    return Router;\n  },\n  matchesMiddleware: function () {\n    return matchesMiddleware;\n  }\n});\nconst _interop_require_default = require(\"@swc/helpers/_/_interop_require_default\");\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\nconst _removetrailingslash = require(\"./utils/remove-trailing-slash\");\nconst _routeloader = require(\"../../../client/route-loader\");\nconst _script = require(\"../../../client/script\");\nconst _iserror = /*#__PURE__*/_interop_require_wildcard._(require(\"../../../lib/is-error\"));\nconst _denormalizepagepath = require(\"../page-path/denormalize-page-path\");\nconst _normalizelocalepath = require(\"../i18n/normalize-locale-path\");\nconst _mitt = /*#__PURE__*/_interop_require_default._(require(\"../mitt\"));\nconst _utils = require(\"../utils\");\nconst _isdynamic = require(\"./utils/is-dynamic\");\nconst _parserelativeurl = require(\"./utils/parse-relative-url\");\nconst _resolverewrites = /*#__PURE__*/_interop_require_default._(require(\"./utils/resolve-rewrites\"));\nconst _routematcher = require(\"./utils/route-matcher\");\nconst _routeregex = require(\"./utils/route-regex\");\nconst _formaturl = require(\"./utils/format-url\");\nconst _detectdomainlocale = require(\"../../../client/detect-domain-locale\");\nconst _parsepath = require(\"./utils/parse-path\");\nconst _addlocale = require(\"../../../client/add-locale\");\nconst _removelocale = require(\"../../../client/remove-locale\");\nconst _removebasepath = require(\"../../../client/remove-base-path\");\nconst _addbasepath = require(\"../../../client/add-base-path\");\nconst _hasbasepath = require(\"../../../client/has-base-path\");\nconst _resolvehref = require(\"../../../client/resolve-href\");\nconst _isapiroute = require(\"../../../lib/is-api-route\");\nconst _getnextpathnameinfo = require(\"./utils/get-next-pathname-info\");\nconst _formatnextpathnameinfo = require(\"./utils/format-next-pathname-info\");\nconst _comparestates = require(\"./utils/compare-states\");\nconst _islocalurl = require(\"./utils/is-local-url\");\nconst _isbot = require(\"./utils/is-bot\");\nconst _omit = require(\"./utils/omit\");\nconst _interpolateas = require(\"./utils/interpolate-as\");\nconst _handlesmoothscroll = require(\"./utils/handle-smooth-scroll\");\nconst _constants = require(\"../../../lib/constants\");\nfunction buildCancellationError() {\n  return Object.assign(Object.defineProperty(new Error('Route Cancelled'), \"__NEXT_ERROR_CODE\", {\n    value: \"E315\",\n    enumerable: false,\n    configurable: true\n  }), {\n    cancelled: true\n  });\n}\nasync function matchesMiddleware(options) {\n  const matchers = await Promise.resolve(options.router.pageLoader.getMiddleware());\n  if (!matchers) return false;\n  const {\n    pathname: asPathname\n  } = (0, _parsepath.parsePath)(options.asPath);\n  // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n  const cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n  const asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));\n  // Check only path match on client. Matching \"has\" should be done on server\n  // where we can access more info such as headers, HttpOnly cookie, etc.\n  return matchers.some(m => new RegExp(m.regexp).test(asWithBasePathAndLocale));\n}\nfunction stripOrigin(url) {\n  const origin = (0, _utils.getLocationOrigin)();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  let [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(router, url, true);\n  const origin = (0, _utils.getLocationOrigin)();\n  const hrefWasAbsolute = resolvedHref.startsWith(origin);\n  const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  const preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n  const preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n  };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n  const cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n  if (cleanPathname === '/404' || cleanPathname === '/_error') {\n    return pathname;\n  }\n  // handle resolving href for dynamic routes\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(page => {\n      if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n  return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n  const nextConfig = {\n    basePath: options.router.basePath,\n    i18n: {\n      locales: options.router.locales\n    },\n    trailingSlash: Boolean(process.env.__NEXT_TRAILING_SLASH)\n  };\n  const rewriteHeader = response.headers.get('x-nextjs-rewrite');\n  let rewriteTarget = rewriteHeader || response.headers.get('x-nextjs-matched-path');\n  const matchedPath = response.headers.get(_constants.MATCHED_PATH_HEADER);\n  if (matchedPath && !rewriteTarget && !matchedPath.includes('__next_data_catchall') && !matchedPath.includes('/_error') && !matchedPath.includes('/404')) {\n    // leverage x-matched-path to detect next.config.js rewrites\n    rewriteTarget = matchedPath;\n  }\n  if (rewriteTarget) {\n    if (rewriteTarget.startsWith('/') || process.env.__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE) {\n      const parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n      const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n        nextConfig,\n        parseData: true\n      });\n      let fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n      return Promise.all([options.router.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)()]).then(param => {\n        let [pages, {\n          __rewrites: rewrites\n        }] = param;\n        let as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n        if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n          const parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n            nextConfig: process.env.__NEXT_HAS_REWRITES ? undefined : nextConfig,\n            parseData: true\n          });\n          as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n          parsedRewriteTarget.pathname = as;\n        }\n        if (process.env.__NEXT_HAS_REWRITES) {\n          const result = (0, _resolverewrites.default)(as, pages, rewrites, parsedRewriteTarget.query, path => resolveDynamicRoute(path, pages), options.router.locales);\n          if (result.matchedPage) {\n            parsedRewriteTarget.pathname = result.parsedAs.pathname;\n            as = parsedRewriteTarget.pathname;\n            Object.assign(parsedRewriteTarget.query, result.parsedAs.query);\n          }\n        } else if (!pages.includes(fsPathname)) {\n          const resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n          if (resolvedPathname !== fsPathname) {\n            fsPathname = resolvedPathname;\n          }\n        }\n        const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n        if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n          const matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n          Object.assign(parsedRewriteTarget.query, matches || {});\n        }\n        return {\n          type: 'rewrite',\n          parsedAs: parsedRewriteTarget,\n          resolvedHref\n        };\n      });\n    }\n    const src = (0, _parsepath.parsePath)(source);\n    const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n      ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n        nextConfig,\n        parseData: true\n      }),\n      defaultLocale: options.router.defaultLocale,\n      buildId: ''\n    });\n    return Promise.resolve({\n      type: 'redirect-external',\n      destination: \"\" + pathname + src.query + src.hash\n    });\n  }\n  const redirectTarget = response.headers.get('x-nextjs-redirect');\n  if (redirectTarget) {\n    if (redirectTarget.startsWith('/')) {\n      const src = (0, _parsepath.parsePath)(redirectTarget);\n      const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n        ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n          nextConfig,\n          parseData: true\n        }),\n        defaultLocale: options.router.defaultLocale,\n        buildId: ''\n      });\n      return Promise.resolve({\n        type: 'redirect-internal',\n        newAs: \"\" + pathname + src.query + src.hash,\n        newUrl: \"\" + pathname + src.query + src.hash\n      });\n    }\n    return Promise.resolve({\n      type: 'redirect-external',\n      destination: redirectTarget\n    });\n  }\n  return Promise.resolve({\n    type: 'next'\n  });\n}\nasync function withMiddlewareEffects(options) {\n  const matches = await matchesMiddleware(options);\n  if (!matches || !options.fetchData) {\n    return null;\n  }\n  const data = await options.fetchData();\n  const effect = await getMiddlewareData(data.dataHref, data.response, options);\n  return {\n    dataHref: data.dataHref,\n    json: data.json,\n    response: data.response,\n    text: data.text,\n    cacheKey: data.cacheKey,\n    effect\n  };\n}\nconst manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== 'undefined' && 'scrollRestoration' in window.history && !!function () {\n  try {\n    let v = '__next';\n    // eslint-disable-next-line no-sequences\n    return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;\n  } catch (n) {}\n}();\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts, options) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` won’t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: 'same-origin',\n    method: options.method || 'GET',\n    headers: Object.assign({}, options.headers, {\n      'x-nextjs-data': '1'\n    })\n  }).then(response => {\n    return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n  });\n}\nfunction tryToParseAsJSON(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return null;\n  }\n}\nfunction fetchNextData(param) {\n  let {\n    dataHref,\n    inflightCache,\n    isPrefetch,\n    hasMiddleware,\n    isServerRender,\n    parseJSON,\n    persistCache,\n    isBackground,\n    unstable_skipClientCache\n  } = param;\n  const {\n    href: cacheKey\n  } = new URL(dataHref, window.location.href);\n  const getData = params => {\n    var _params_method;\n    return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n      headers: Object.assign({}, isPrefetch ? {\n        purpose: 'prefetch'\n      } : {}, isPrefetch && hasMiddleware ? {\n        'x-middleware-prefetch': '1'\n      } : {}, process.env.NEXT_DEPLOYMENT_ID ? {\n        'x-deployment-id': process.env.NEXT_DEPLOYMENT_ID\n      } : {}),\n      method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : 'GET'\n    }).then(response => {\n      if (response.ok && (params == null ? void 0 : params.method) === 'HEAD') {\n        return {\n          dataHref,\n          response,\n          text: '',\n          json: {},\n          cacheKey\n        };\n      }\n      return response.text().then(text => {\n        if (!response.ok) {\n          /**\n          * When the data response is a redirect because of a middleware\n          * we do not consider it an error. The headers must bring the\n          * mapped location.\n          * TODO: Change the status code in the handler.\n          */\n          if (hasMiddleware && [301, 302, 307, 308].includes(response.status)) {\n            return {\n              dataHref,\n              response,\n              text,\n              json: {},\n              cacheKey\n            };\n          }\n          if (response.status === 404) {\n            var _tryToParseAsJSON;\n            if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n              return {\n                dataHref,\n                json: {\n                  notFound: SSG_DATA_NOT_FOUND\n                },\n                response,\n                text,\n                cacheKey\n              };\n            }\n          }\n          const error = Object.defineProperty(new Error(\"Failed to load static props\"), \"__NEXT_ERROR_CODE\", {\n            value: \"E124\",\n            enumerable: false,\n            configurable: true\n          });\n          /**\n          * We should only trigger a server-side transition if this was\n          * caused on a client-side transition. Otherwise, we'd get into\n          * an infinite loop.\n          */\n          if (!isServerRender) {\n            (0, _routeloader.markAssetError)(error);\n          }\n          throw error;\n        }\n        return {\n          dataHref,\n          json: parseJSON ? tryToParseAsJSON(text) : null,\n          response,\n          text,\n          cacheKey\n        };\n      });\n    }).then(data => {\n      if (!persistCache || process.env.NODE_ENV !== 'production' || data.response.headers.get('x-middleware-cache') === 'no-cache') {\n        delete inflightCache[cacheKey];\n      }\n      return data;\n    }).catch(err => {\n      if (!unstable_skipClientCache) {\n        delete inflightCache[cacheKey];\n      }\n      if (\n      // chrome\n      err.message === 'Failed to fetch' ||\n      // firefox\n      err.message === 'NetworkError when attempting to fetch resource.' ||\n      // safari\n      err.message === 'Load failed') {\n        (0, _routeloader.markAssetError)(err);\n      }\n      throw err;\n    });\n  };\n  // when skipping client cache we wait to update\n  // inflight cache until successful data response\n  // this allows racing click event with fetching newer data\n  // without blocking navigation when stale data is available\n  if (unstable_skipClientCache && persistCache) {\n    return getData({}).then(data => {\n      if (data.response.headers.get('x-middleware-cache') !== 'no-cache') {\n        // only update cache if not marked as no-cache\n        inflightCache[cacheKey] = Promise.resolve(data);\n      }\n      return data;\n    });\n  }\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey];\n  }\n  return inflightCache[cacheKey] = getData(isBackground ? {\n    method: 'HEAD'\n  } : {});\n}\nfunction createKey() {\n  return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(param) {\n  let {\n    url,\n    router\n  } = param;\n  // ensure we don't trigger a hard navigation to the same\n  // URL as this can end up with an infinite refresh\n  if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n    throw Object.defineProperty(new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href), \"__NEXT_ERROR_CODE\", {\n      value: \"E282\",\n      enumerable: false,\n      configurable: true\n    });\n  }\n  window.location.href = url;\n}\nconst getCancelledHandler = param => {\n  let {\n    route,\n    router\n  } = param;\n  let cancelled = false;\n  const cancel = router.clc = () => {\n    cancelled = true;\n  };\n  const handleCancelled = () => {\n    if (cancelled) {\n      const error = Object.defineProperty(new Error('Abort fetching component for route: \"' + route + '\"'), \"__NEXT_ERROR_CODE\", {\n        value: \"E483\",\n        enumerable: false,\n        configurable: true\n      });\n      error.cancelled = true;\n      throw error;\n    }\n    if (cancel === router.clc) {\n      router.clc = null;\n    }\n  };\n  return handleCancelled;\n};\nclass Router {\n  reload() {\n    window.location.reload();\n  }\n  /**\n  * Go back in history\n  */\n  back() {\n    window.history.back();\n  }\n  /**\n  * Go forward in history\n  */\n  forward() {\n    window.history.forward();\n  }\n  /**\n  * Performs a `pushState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n  push(url, as, options) {\n    if (options === void 0) options = {};\n    if (process.env.__NEXT_SCROLL_RESTORATION) {\n      // TODO: remove in the future when we update history before route change\n      // is complete, as the popstate event should handle this capture.\n      if (manualScrollRestoration) {\n        try {\n          // Snapshot scroll position right before navigating to a new page:\n          sessionStorage.setItem('__next_scroll_' + this._key, JSON.stringify({\n            x: self.pageXOffset,\n            y: self.pageYOffset\n          }));\n        } catch (e) {}\n      }\n    }\n    ;\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change('pushState', url, as, options);\n  }\n  /**\n  * Performs a `replaceState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n  replace(url, as, options) {\n    if (options === void 0) options = {};\n    ;\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change('replaceState', url, as, options);\n  }\n  async _bfl(as, resolvedAs, locale, skipNavigate) {\n    if (process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {\n      if (!this._bfl_s && !this._bfl_d) {\n        const {\n          BloomFilter\n        } = require('../../lib/bloom-filter');\n        let staticFilterData;\n        let dynamicFilterData;\n        try {\n          ;\n          ({\n            __routerFilterStatic: staticFilterData,\n            __routerFilterDynamic: dynamicFilterData\n          } = await (0, _routeloader.getClientBuildManifest)());\n        } catch (err) {\n          // failed to load build manifest hard navigate\n          // to be safe\n          console.error(err);\n          if (skipNavigate) {\n            return true;\n          }\n          handleHardNavigation({\n            url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n            router: this\n          });\n          return new Promise(() => {});\n        }\n        const routerFilterSValue = process.env.__NEXT_CLIENT_ROUTER_S_FILTER;\n        if (!staticFilterData && routerFilterSValue) {\n          staticFilterData = routerFilterSValue ? routerFilterSValue : undefined;\n        }\n        const routerFilterDValue = process.env.__NEXT_CLIENT_ROUTER_D_FILTER;\n        if (!dynamicFilterData && routerFilterDValue) {\n          dynamicFilterData = routerFilterDValue ? routerFilterDValue : undefined;\n        }\n        if (staticFilterData == null ? void 0 : staticFilterData.numHashes) {\n          this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n          this._bfl_s.import(staticFilterData);\n        }\n        if (dynamicFilterData == null ? void 0 : dynamicFilterData.numHashes) {\n          this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n          this._bfl_d.import(dynamicFilterData);\n        }\n      }\n      let matchesBflStatic = false;\n      let matchesBflDynamic = false;\n      const pathsToCheck = [{\n        as\n      }, {\n        as: resolvedAs\n      }];\n      for (const {\n        as: curAs,\n        allowMatchCurrent\n      } of pathsToCheck) {\n        if (curAs) {\n          const asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, 'http://n').pathname);\n          const asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));\n          if (allowMatchCurrent || asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, 'http://n').pathname)) {\n            var _this__bfl_s, _this__bfl_s1;\n            matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = this._bfl_s) == null ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = this._bfl_s) == null ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));\n            for (const normalizedAS of [asNoSlash, asNoSlashLocale]) {\n              // if any sub-path of as matches a dynamic filter path\n              // it should be hard navigated\n              const curAsParts = normalizedAS.split('/');\n              for (let i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++) {\n                var _this__bfl_d;\n                const currentPart = curAsParts.slice(0, i).join('/');\n                if (currentPart && ((_this__bfl_d = this._bfl_d) == null ? void 0 : _this__bfl_d.contains(currentPart))) {\n                  matchesBflDynamic = true;\n                  break;\n                }\n              }\n            }\n            // if the client router filter is matched then we trigger\n            // a hard navigation\n            if (matchesBflStatic || matchesBflDynamic) {\n              if (skipNavigate) {\n                return true;\n              }\n              handleHardNavigation({\n                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                router: this\n              });\n              return new Promise(() => {});\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n  async change(method, url, as, options, forcedScroll) {\n    var _this_components_pathname;\n    if (!(0, _islocalurl.isLocalURL)(url)) {\n      handleHardNavigation({\n        url,\n        router: this\n      });\n      return false;\n    }\n    // WARNING: `_h` is an internal option for handing Next.js client-side\n    // hydration. Your app should _never_ use this property. It may change at\n    // any time without notice.\n    const isQueryUpdating = options._h === 1;\n    if (!isQueryUpdating && !options.shallow) {\n      await this._bfl(as, undefined, options.locale);\n    }\n    let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n    const nextState = {\n      ...this.state\n    };\n    // for static pages with query params in the URL we delay\n    // marking the router ready until after the query is updated\n    // or a navigation has occurred\n    const readyStateChange = this.isReady !== true;\n    this.isReady = true;\n    const isSsr = this.isSsr;\n    if (!isQueryUpdating) {\n      this.isSsr = false;\n    }\n    // if a route transition is already in progress before\n    // the query updating is triggered ignore query updating\n    if (isQueryUpdating && this.clc) {\n      return false;\n    }\n    const prevLocale = nextState.locale;\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      nextState.locale = options.locale === false ? this.defaultLocale : options.locale || nextState.locale;\n      if (typeof options.locale === 'undefined') {\n        options.locale = nextState.locale;\n      }\n      const parsedAs = (0, _parserelativeurl.parseRelativeUrl)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as);\n      const localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);\n      if (localePathResult.detectedLocale) {\n        nextState.locale = localePathResult.detectedLocale;\n        parsedAs.pathname = (0, _addbasepath.addBasePath)(parsedAs.pathname);\n        as = (0, _formaturl.formatWithValidation)(parsedAs);\n        url = (0, _addbasepath.addBasePath)((0, _normalizelocalepath.normalizeLocalePath)((0, _hasbasepath.hasBasePath)(url) ? (0, _removebasepath.removeBasePath)(url) : url, this.locales).pathname);\n      }\n      let didNavigate = false;\n      // we need to wrap this in the env check again since regenerator runtime\n      // moves this on its own due to the return\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        var _this_locales;\n        // if the locale isn't configured hard navigate to show 404 page\n        if (!((_this_locales = this.locales) == null ? void 0 : _this_locales.includes(nextState.locale))) {\n          parsedAs.pathname = (0, _addlocale.addLocale)(parsedAs.pathname, nextState.locale);\n          handleHardNavigation({\n            url: (0, _formaturl.formatWithValidation)(parsedAs),\n            router: this\n          });\n          // this was previously a return but was removed in favor\n          // of better dead code elimination with regenerator runtime\n          didNavigate = true;\n        }\n      }\n      const detectedDomain = (0, _detectdomainlocale.detectDomainLocale)(this.domainLocales, undefined, nextState.locale);\n      // we need to wrap this in the env check again since regenerator runtime\n      // moves this on its own due to the return\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        // if we are navigating to a domain locale ensure we redirect to the\n        // correct domain\n        if (!didNavigate && detectedDomain && this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {\n          const asNoBasePath = (0, _removebasepath.removeBasePath)(as);\n          handleHardNavigation({\n            url: \"http\" + (detectedDomain.http ? '' : 's') + \"://\" + detectedDomain.domain + (0, _addbasepath.addBasePath)(\"\" + (nextState.locale === detectedDomain.defaultLocale ? '' : \"/\" + nextState.locale) + (asNoBasePath === '/' ? '' : asNoBasePath) || '/'),\n            router: this\n          });\n          // this was previously a return but was removed in favor\n          // of better dead code elimination with regenerator runtime\n          didNavigate = true;\n        }\n      }\n      if (didNavigate) {\n        return new Promise(() => {});\n      }\n    }\n    // marking route changes as a navigation start entry\n    if (_utils.ST) {\n      performance.mark('routeChange');\n    }\n    const {\n      shallow = false,\n      scroll = true\n    } = options;\n    const routeProps = {\n      shallow\n    };\n    if (this._inFlightRoute && this.clc) {\n      if (!isSsr) {\n        Router.events.emit('routeChangeError', buildCancellationError(), this._inFlightRoute, routeProps);\n      }\n      this.clc();\n      this.clc = null;\n    }\n    as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));\n    const cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n    this._inFlightRoute = as;\n    const localeChange = prevLocale !== nextState.locale;\n    // If the url change is only related to a hash change\n    // We should not proceed. We should only change the state.\n    if (!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange) {\n      nextState.asPath = cleanedAs;\n      Router.events.emit('hashChangeStart', as, routeProps);\n      // TODO: do we need the resolved href when only a hash change?\n      this.changeState(method, url, as, {\n        ...options,\n        scroll: false\n      });\n      if (scroll) {\n        this.scrollToHash(cleanedAs);\n      }\n      try {\n        await this.set(nextState, this.components[nextState.route], null);\n      } catch (err) {\n        if ((0, _iserror.default)(err) && err.cancelled) {\n          Router.events.emit('routeChangeError', err, cleanedAs, routeProps);\n        }\n        throw err;\n      }\n      Router.events.emit('hashChangeComplete', as, routeProps);\n      return true;\n    }\n    let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n    let {\n      pathname,\n      query\n    } = parsed;\n    // The build manifest needs to be loaded before auto-static dynamic pages\n    // get their query parameters to allow ensuring they can be parsed properly\n    // when rewritten to\n    let pages, rewrites;\n    try {\n      ;\n      [pages, {\n        __rewrites: rewrites\n      }] = await Promise.all([this.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)(), this.pageLoader.getMiddleware()]);\n    } catch (err) {\n      // If we fail to resolve the page list or client-build manifest, we must\n      // do a server-side transition:\n      handleHardNavigation({\n        url: as,\n        router: this\n      });\n      return false;\n    }\n    // If asked to change the current URL we should reload the current page\n    // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n    // We also need to set the method = replaceState always\n    // as this should not go into the history (That's how browsers work)\n    // We should compare the new asPath to the current asPath, not the url\n    if (!this.urlIsNew(cleanedAs) && !localeChange) {\n      method = 'replaceState';\n    }\n    // we need to resolve the as value using rewrites for dynamic SSG\n    // pages to allow building the data URL correctly\n    let resolvedAs = as;\n    // url and as should always be prefixed with basePath by this\n    // point by either next/link or router.push/replace so strip the\n    // basePath from the pathname to match the pages dir 1-to-1\n    pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n    let route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n    const parsedAsPathname = as.startsWith('/') && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n    // if we detected the path as app route during prefetching\n    // trigger hard navigation\n    if ((_this_components_pathname = this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter) {\n      handleHardNavigation({\n        url: as,\n        router: this\n      });\n      return new Promise(() => {});\n    }\n    const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));\n    // we don't attempt resolve asPath when we need to execute\n    // middleware as the resolving will occur server-side\n    const isMiddlewareMatch = !options.shallow && (await matchesMiddleware({\n      asPath: as,\n      locale: nextState.locale,\n      router: this\n    }));\n    if (isQueryUpdating && isMiddlewareMatch) {\n      shouldResolveHref = false;\n    }\n    if (shouldResolveHref && pathname !== '/_error') {\n      ;\n      options._shouldResolveHref = true;\n      if (process.env.__NEXT_HAS_REWRITES && as.startsWith('/')) {\n        const rewritesResult = (0, _resolverewrites.default)((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, nextState.locale), true), pages, rewrites, query, p => resolveDynamicRoute(p, pages), this.locales);\n        if (rewritesResult.externalDest) {\n          handleHardNavigation({\n            url: as,\n            router: this\n          });\n          return true;\n        }\n        if (!isMiddlewareMatch) {\n          resolvedAs = rewritesResult.asPath;\n        }\n        if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n          // if this directly matches a page we need to update the href to\n          // allow the correct page chunk to be loaded\n          pathname = rewritesResult.resolvedHref;\n          parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n          if (!isMiddlewareMatch) {\n            url = (0, _formaturl.formatWithValidation)(parsed);\n          }\n        }\n      } else {\n        parsed.pathname = resolveDynamicRoute(pathname, pages);\n        if (parsed.pathname !== pathname) {\n          pathname = parsed.pathname;\n          parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n          if (!isMiddlewareMatch) {\n            url = (0, _formaturl.formatWithValidation)(parsed);\n          }\n        }\n      }\n    }\n    if (!(0, _islocalurl.isLocalURL)(as)) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw Object.defineProperty(new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\"), \"__NEXT_ERROR_CODE\", {\n          value: \"E380\",\n          enumerable: false,\n          configurable: true\n        });\n      }\n      handleHardNavigation({\n        url: as,\n        router: this\n      });\n      return false;\n    }\n    resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n    route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n    let routeMatch = false;\n    if ((0, _isdynamic.isDynamicRoute)(route)) {\n      const parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n      const asPathname = parsedAs.pathname;\n      const routeRegex = (0, _routeregex.getRouteRegex)(route);\n      routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n      const shouldInterpolate = route === asPathname;\n      const interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n      if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n        const missingParams = Object.keys(routeRegex.groups).filter(param => !query[param] && !routeRegex.groups[param].optional);\n        if (missingParams.length > 0 && !isMiddlewareMatch) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(', ') + \" in the `href`'s `query`\"));\n          }\n          throw Object.defineProperty(new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(', ') + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'))), \"__NEXT_ERROR_CODE\", {\n            value: \"E344\",\n            enumerable: false,\n            configurable: true\n          });\n        }\n      } else if (shouldInterpolate) {\n        as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {\n          pathname: interpolatedAs.result,\n          query: (0, _omit.omit)(query, interpolatedAs.params)\n        }));\n      } else {\n        // Merge params into `query`, overwriting any specified in search\n        Object.assign(query, routeMatch);\n      }\n    }\n    if (!isQueryUpdating) {\n      Router.events.emit('routeChangeStart', as, routeProps);\n    }\n    const isErrorRoute = this.pathname === '/404' || this.pathname === '/_error';\n    try {\n      var _self___NEXT_DATA___props_pageProps, _self___NEXT_DATA___props, _routeInfo_props;\n      let routeInfo = await this.getRouteInfo({\n        route,\n        pathname,\n        query,\n        as,\n        resolvedAs,\n        routeProps,\n        locale: nextState.locale,\n        isPreview: nextState.isPreview,\n        hasMiddleware: isMiddlewareMatch,\n        unstable_skipClientCache: options.unstable_skipClientCache,\n        isQueryUpdating: isQueryUpdating && !this.isFallback,\n        isMiddlewareRewrite\n      });\n      if (!isQueryUpdating && !options.shallow) {\n        await this._bfl(as, 'resolvedAs' in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n      }\n      if ('route' in routeInfo && isMiddlewareMatch) {\n        pathname = routeInfo.route || route;\n        route = pathname;\n        if (!routeProps.shallow) {\n          query = Object.assign({}, routeInfo.query || {}, query);\n        }\n        const cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n        if (routeMatch && pathname !== cleanedParsedPathname) {\n          Object.keys(routeMatch).forEach(key => {\n            if (routeMatch && query[key] === routeMatch[key]) {\n              delete query[key];\n            }\n          });\n        }\n        if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n          const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n          let rewriteAs = prefixedAs;\n          if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n            rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n          }\n          if (process.env.__NEXT_I18N_SUPPORT) {\n            const localeResult = (0, _normalizelocalepath.normalizeLocalePath)(rewriteAs, this.locales);\n            nextState.locale = localeResult.detectedLocale || nextState.locale;\n            rewriteAs = localeResult.pathname;\n          }\n          const routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n          const curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(new URL(rewriteAs, location.href).pathname);\n          if (curRouteMatch) {\n            Object.assign(query, curRouteMatch);\n          }\n        }\n      }\n      // If the routeInfo brings a redirect we simply apply it.\n      if ('type' in routeInfo) {\n        if (routeInfo.type === 'redirect-internal') {\n          return this.change(method, routeInfo.newUrl, routeInfo.newAs, options);\n        } else {\n          handleHardNavigation({\n            url: routeInfo.destination,\n            router: this\n          });\n          return new Promise(() => {});\n        }\n      }\n      const component = routeInfo.Component;\n      if (component && component.unstable_scriptLoader) {\n        const scripts = [].concat(component.unstable_scriptLoader());\n        scripts.forEach(script => {\n          (0, _script.handleClientScriptLoad)(script.props);\n        });\n      }\n      // handle redirect on client-transition\n      if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {\n        if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n          // Use the destination from redirect without adding locale\n          options.locale = false;\n          const destination = routeInfo.props.pageProps.__N_REDIRECT;\n          // check if destination is internal (resolves to a page) and attempt\n          // client-navigation if it is falling back to hard navigation if\n          // it's not\n          if (destination.startsWith('/') && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n            const parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n            parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n            const {\n              url: newUrl,\n              as: newAs\n            } = prepareUrlAs(this, destination, destination);\n            return this.change(method, newUrl, newAs, options);\n          }\n          handleHardNavigation({\n            url: destination,\n            router: this\n          });\n          return new Promise(() => {});\n        }\n        nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n        // handle SSG data 404\n        if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {\n          let notFoundRoute;\n          try {\n            await this.fetchComponent('/404');\n            notFoundRoute = '/404';\n          } catch (_) {\n            notFoundRoute = '/_error';\n          }\n          routeInfo = await this.getRouteInfo({\n            route: notFoundRoute,\n            pathname: notFoundRoute,\n            query,\n            as,\n            resolvedAs,\n            routeProps: {\n              shallow: false\n            },\n            locale: nextState.locale,\n            isPreview: nextState.isPreview,\n            isNotFound: true\n          });\n          if ('type' in routeInfo) {\n            throw Object.defineProperty(new Error(\"Unexpected middleware effect on /404\"), \"__NEXT_ERROR_CODE\", {\n              value: \"E158\",\n              enumerable: false,\n              configurable: true\n            });\n          }\n        }\n      }\n      if (isQueryUpdating && this.pathname === '/_error' && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n        // ensure statusCode is still correct for static 500 page\n        // when updating query information\n        routeInfo.props.pageProps.statusCode = 500;\n      }\n      var _routeInfo_route;\n      // shallow routing is only allowed for same page URL changes.\n      const isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n      var _options_scroll;\n      const shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;\n      const resetScroll = shouldScroll ? {\n        x: 0,\n        y: 0\n      } : null;\n      const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n      // the new state that the router gonna set\n      const upcomingRouterState = {\n        ...nextState,\n        route,\n        pathname,\n        query,\n        asPath: cleanedAs,\n        isFallback: false\n      };\n      // When the page being rendered is the 404 page, we should only update the\n      // query parameters. Route changes here might add the basePath when it\n      // wasn't originally present. This is also why this block is before the\n      // below `changeState` call which updates the browser's history (changing\n      // the URL).\n      if (isQueryUpdating && isErrorRoute) {\n        var _self___NEXT_DATA___props_pageProps1, _self___NEXT_DATA___props1, _routeInfo_props1;\n        routeInfo = await this.getRouteInfo({\n          route: this.pathname,\n          pathname: this.pathname,\n          query,\n          as,\n          resolvedAs,\n          routeProps: {\n            shallow: false\n          },\n          locale: nextState.locale,\n          isPreview: nextState.isPreview,\n          isQueryUpdating: isQueryUpdating && !this.isFallback\n        });\n        if ('type' in routeInfo) {\n          throw Object.defineProperty(new Error(\"Unexpected middleware effect on \" + this.pathname), \"__NEXT_ERROR_CODE\", {\n            value: \"E225\",\n            enumerable: false,\n            configurable: true\n          });\n        }\n        if (this.pathname === '/_error' && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n          // ensure statusCode is still correct for static 500 page\n          // when updating query information\n          routeInfo.props.pageProps.statusCode = 500;\n        }\n        try {\n          await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n        } catch (err) {\n          if ((0, _iserror.default)(err) && err.cancelled) {\n            Router.events.emit('routeChangeError', err, cleanedAs, routeProps);\n          }\n          throw err;\n        }\n        return true;\n      }\n      Router.events.emit('beforeHistoryChange', as, routeProps);\n      this.changeState(method, url, as, options);\n      // for query updates we can skip it if the state is unchanged and we don't\n      // need to scroll\n      // https://github.com/vercel/next.js/issues/37139\n      const canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);\n      if (!canSkipUpdating) {\n        try {\n          await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n        } catch (e) {\n          if (e.cancelled) routeInfo.error = routeInfo.error || e;else throw e;\n        }\n        if (routeInfo.error) {\n          if (!isQueryUpdating) {\n            Router.events.emit('routeChangeError', routeInfo.error, cleanedAs, routeProps);\n          }\n          throw routeInfo.error;\n        }\n        if (process.env.__NEXT_I18N_SUPPORT) {\n          if (nextState.locale) {\n            document.documentElement.lang = nextState.locale;\n          }\n        }\n        if (!isQueryUpdating) {\n          Router.events.emit('routeChangeComplete', as, routeProps);\n        }\n        // A hash mark # is the optional last part of a URL\n        const hashRegex = /#.+$/;\n        if (shouldScroll && hashRegex.test(as)) {\n          this.scrollToHash(as);\n        }\n      }\n      return true;\n    } catch (err) {\n      if ((0, _iserror.default)(err) && err.cancelled) {\n        return false;\n      }\n      throw err;\n    }\n  }\n  changeState(method, url, as, options) {\n    if (options === void 0) options = {};\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof window.history === 'undefined') {\n        console.error(\"Warning: window.history is not available.\");\n        return;\n      }\n      if (typeof window.history[method] === 'undefined') {\n        console.error(\"Warning: window.history.\" + method + \" is not available\");\n        return;\n      }\n    }\n    if (method !== 'pushState' || (0, _utils.getURL)() !== as) {\n      this._shallow = options.shallow;\n      window.history[method]({\n        url,\n        as,\n        options,\n        __N: true,\n        key: this._key = method !== 'pushState' ? this._key : createKey()\n      },\n      // Most browsers currently ignores this parameter, although they may use it in the future.\n      // Passing the empty string here should be safe against future changes to the method.\n      // https://developer.mozilla.org/docs/Web/API/History/replaceState\n      '', as);\n    }\n  }\n  async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n    if (err.cancelled) {\n      // bubble up cancellation errors\n      throw err;\n    }\n    if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {\n      Router.events.emit('routeChangeError', err, as, routeProps);\n      // If we can't load the page it could be one of following reasons\n      //  1. Page doesn't exists\n      //  2. Page does exist in a different zone\n      //  3. Internal error while loading the page\n      // So, doing a hard reload is the proper way to deal with this.\n      handleHardNavigation({\n        url: as,\n        router: this\n      });\n      // Changing the URL doesn't block executing the current code path.\n      // So let's throw a cancellation error stop the routing logic.\n      throw buildCancellationError();\n    }\n    console.error(err);\n    try {\n      let props;\n      const {\n        page: Component,\n        styleSheets\n      } = await this.fetchComponent('/_error');\n      const routeInfo = {\n        props,\n        Component,\n        styleSheets,\n        err,\n        error: err\n      };\n      if (!routeInfo.props) {\n        try {\n          routeInfo.props = await this.getInitialProps(Component, {\n            err,\n            pathname,\n            query\n          });\n        } catch (gipErr) {\n          console.error('Error in error page `getInitialProps`: ', gipErr);\n          routeInfo.props = {};\n        }\n      }\n      return routeInfo;\n    } catch (routeInfoErr) {\n      return this.handleRouteInfoError((0, _iserror.default)(routeInfoErr) ? routeInfoErr : Object.defineProperty(new Error(routeInfoErr + ''), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n      }), pathname, query, as, routeProps, true);\n    }\n  }\n  async getRouteInfo(param) {\n    let {\n      route: requestedRoute,\n      pathname,\n      query,\n      as,\n      resolvedAs,\n      routeProps,\n      locale,\n      hasMiddleware,\n      isPreview,\n      unstable_skipClientCache,\n      isQueryUpdating,\n      isMiddlewareRewrite,\n      isNotFound\n    } = param;\n    /**\n    * This `route` binding can change if there's a rewrite\n    * so we keep a reference to the original requested route\n    * so we can store the cache for it and avoid re-requesting every time\n    * for shallow routing purposes.\n    */\n    let route = requestedRoute;\n    try {\n      var _data_effect, _data_effect1, _data_effect2, _data_response;\n      let existingInfo = this.components[route];\n      if (routeProps.shallow && existingInfo && this.route === route) {\n        return existingInfo;\n      }\n      const handleCancelled = getCancelledHandler({\n        route,\n        router: this\n      });\n      if (hasMiddleware) {\n        existingInfo = undefined;\n      }\n      let cachedRouteInfo = existingInfo && !('initial' in existingInfo) && process.env.NODE_ENV !== 'development' ? existingInfo : undefined;\n      const isBackground = isQueryUpdating;\n      const fetchNextDataParams = {\n        dataHref: this.pageLoader.getDataHref({\n          href: (0, _formaturl.formatWithValidation)({\n            pathname,\n            query\n          }),\n          skipInterpolation: true,\n          asPath: isNotFound ? '/404' : resolvedAs,\n          locale\n        }),\n        hasMiddleware: true,\n        isServerRender: this.isSsr,\n        parseJSON: true,\n        inflightCache: isBackground ? this.sbc : this.sdc,\n        persistCache: !isPreview,\n        isPrefetch: false,\n        unstable_skipClientCache,\n        isBackground\n      };\n      let data = isQueryUpdating && !isMiddlewareRewrite ? null : await withMiddlewareEffects({\n        fetchData: () => fetchNextData(fetchNextDataParams),\n        asPath: isNotFound ? '/404' : resolvedAs,\n        locale: locale,\n        router: this\n      }).catch(err => {\n        // we don't hard error during query updating\n        // as it's un-necessary and doesn't need to be fatal\n        // unless it is a fallback route and the props can't\n        // be loaded\n        if (isQueryUpdating) {\n          return null;\n        }\n        throw err;\n      });\n      // when rendering error routes we don't apply middleware\n      // effects\n      if (data && (pathname === '/_error' || pathname === '/404')) {\n        data.effect = undefined;\n      }\n      if (isQueryUpdating) {\n        if (!data) {\n          data = {\n            json: self.__NEXT_DATA__.props\n          };\n        } else {\n          data.json = self.__NEXT_DATA__.props;\n        }\n      }\n      handleCancelled();\n      if ((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === 'redirect-internal' || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === 'redirect-external') {\n        return data.effect;\n      }\n      if ((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === 'rewrite') {\n        const resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n        const pages = await this.pageLoader.getPageList();\n        // during query updating the page must match although during\n        // client-transition a redirect that doesn't match a page\n        // can be returned and this should trigger a hard navigation\n        // which is valid for incremental migration\n        if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n          route = resolvedRoute;\n          pathname = data.effect.resolvedHref;\n          query = {\n            ...query,\n            ...data.effect.parsedAs.query\n          };\n          resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname);\n          // Check again the cache with the new destination.\n          existingInfo = this.components[route];\n          if (routeProps.shallow && existingInfo && this.route === route && !hasMiddleware) {\n            // If we have a match with the current route due to rewrite,\n            // we can copy the existing information to the rewritten one.\n            // Then, we return the information along with the matched route.\n            return {\n              ...existingInfo,\n              route\n            };\n          }\n        }\n      }\n      if ((0, _isapiroute.isAPIRoute)(route)) {\n        handleHardNavigation({\n          url: as,\n          router: this\n        });\n        return new Promise(() => {});\n      }\n      const routeInfo = cachedRouteInfo || (await this.fetchComponent(route).then(res => ({\n        Component: res.page,\n        styleSheets: res.styleSheets,\n        __N_SSG: res.mod.__N_SSG,\n        __N_SSP: res.mod.__N_SSP\n      })));\n      if (process.env.NODE_ENV !== 'production') {\n        const {\n          isValidElementType\n        } = require('next/dist/compiled/react-is');\n        if (!isValidElementType(routeInfo.Component)) {\n          throw Object.defineProperty(new Error('The default export is not a React Component in page: \"' + pathname + '\"'), \"__NEXT_ERROR_CODE\", {\n            value: \"E286\",\n            enumerable: false,\n            configurable: true\n          });\n        }\n      }\n      const wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get('x-middleware-skip');\n      const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n      // For non-SSG prefetches that bailed before sending data\n      // we clear the cache to fetch full response\n      if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n        delete this.sdc[data.dataHref];\n      }\n      const {\n        props,\n        cacheKey\n      } = await this._getData(async () => {\n        if (shouldFetchData) {\n          if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {\n            return {\n              cacheKey: data.cacheKey,\n              props: data.json\n            };\n          }\n          const dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : this.pageLoader.getDataHref({\n            href: (0, _formaturl.formatWithValidation)({\n              pathname,\n              query\n            }),\n            asPath: resolvedAs,\n            locale\n          });\n          const fetched = await fetchNextData({\n            dataHref,\n            isServerRender: this.isSsr,\n            parseJSON: true,\n            inflightCache: wasBailedPrefetch ? {} : this.sdc,\n            persistCache: !isPreview,\n            isPrefetch: false,\n            unstable_skipClientCache\n          });\n          return {\n            cacheKey: fetched.cacheKey,\n            props: fetched.json || {}\n          };\n        }\n        return {\n          headers: {},\n          props: await this.getInitialProps(routeInfo.Component,\n          // we provide AppTree later so this needs to be `any`\n          {\n            pathname,\n            query,\n            asPath: as,\n            locale,\n            locales: this.locales,\n            defaultLocale: this.defaultLocale\n          })\n        };\n      });\n      // Only bust the data cache for SSP routes although\n      // middleware can skip cache per request with\n      // x-middleware-cache: no-cache as well\n      if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n        delete this.sdc[cacheKey];\n      }\n      // we kick off a HEAD request in the background\n      // when a non-prefetch request is made to signal revalidation\n      if (!this.isPreview && routeInfo.__N_SSG && process.env.NODE_ENV !== 'development' && !isQueryUpdating) {\n        fetchNextData(Object.assign({}, fetchNextDataParams, {\n          isBackground: true,\n          persistCache: false,\n          inflightCache: this.sbc\n        })).catch(() => {});\n      }\n      props.pageProps = Object.assign({}, props.pageProps);\n      routeInfo.props = props;\n      routeInfo.route = route;\n      routeInfo.query = query;\n      routeInfo.resolvedAs = resolvedAs;\n      this.components[route] = routeInfo;\n      return routeInfo;\n    } catch (err) {\n      return this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps);\n    }\n  }\n  set(state, data, resetScroll) {\n    this.state = state;\n    return this.sub(data, this.components['/_app'].Component, resetScroll);\n  }\n  /**\n  * Callback to execute before replacing router state\n  * @param cb callback to be executed\n  */\n  beforePopState(cb) {\n    this._bps = cb;\n  }\n  onlyAHashChange(as) {\n    if (!this.asPath) return false;\n    const [oldUrlNoHash, oldHash] = this.asPath.split('#', 2);\n    const [newUrlNoHash, newHash] = as.split('#', 2);\n    // Makes sure we scroll to the provided hash if the url/hash are the same\n    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n      return true;\n    }\n    // If the urls are change, there's more than a hash change\n    if (oldUrlNoHash !== newUrlNoHash) {\n      return false;\n    }\n    // If the hash has changed, then it's a hash only change.\n    // This check is necessary to handle both the enter and\n    // leave hash === '' cases. The identity case falls through\n    // and is treated as a next reload.\n    return oldHash !== newHash;\n  }\n  scrollToHash(as) {\n    const [, hash = ''] = as.split('#', 2);\n    (0, _handlesmoothscroll.handleSmoothScroll)(() => {\n      // Scroll to top if the hash is just `#` with no value or `#top`\n      // To mirror browsers\n      if (hash === '' || hash === 'top') {\n        window.scrollTo(0, 0);\n        return;\n      }\n      // Decode hash to make non-latin anchor works.\n      const rawHash = decodeURIComponent(hash);\n      // First we check if the element by id is found\n      const idEl = document.getElementById(rawHash);\n      if (idEl) {\n        idEl.scrollIntoView();\n        return;\n      }\n      // If there's no element with the id, we check the `name` property\n      // To mirror browsers\n      const nameEl = document.getElementsByName(rawHash)[0];\n      if (nameEl) {\n        nameEl.scrollIntoView();\n      }\n    }, {\n      onlyHashChange: this.onlyAHashChange(as)\n    });\n  }\n  urlIsNew(asPath) {\n    return this.asPath !== asPath;\n  }\n  /**\n  * Prefetch page code, you may wait for the data during page rendering.\n  * This feature only works in production!\n  * @param url the href of prefetched page\n  * @param asPath the as path of the prefetched page\n  */\n  async prefetch(url, asPath, options) {\n    if (asPath === void 0) asPath = url;\n    if (options === void 0) options = {};\n    // Prefetch is not supported in development mode because it would trigger on-demand-entries\n    if (process.env.NODE_ENV !== 'production') {\n      return;\n    }\n    if (typeof window !== 'undefined' && (0, _isbot.isBot)(window.navigator.userAgent)) {\n      // No prefetches for bots that render the link since they are typically navigating\n      // links via the equivalent of a hard navigation and hence never utilize these\n      // prefetches.\n      return;\n    }\n    let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n    const urlPathname = parsed.pathname;\n    let {\n      pathname,\n      query\n    } = parsed;\n    const originalPathname = pathname;\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      if (options.locale === false) {\n        pathname = (0, _normalizelocalepath.normalizeLocalePath)(pathname, this.locales).pathname;\n        parsed.pathname = pathname;\n        url = (0, _formaturl.formatWithValidation)(parsed);\n        let parsedAs = (0, _parserelativeurl.parseRelativeUrl)(asPath);\n        const localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);\n        parsedAs.pathname = localePathResult.pathname;\n        options.locale = localePathResult.detectedLocale || this.defaultLocale;\n        asPath = (0, _formaturl.formatWithValidation)(parsedAs);\n      }\n    }\n    const pages = await this.pageLoader.getPageList();\n    let resolvedAs = asPath;\n    const locale = typeof options.locale !== 'undefined' ? options.locale || undefined : this.locale;\n    const isMiddlewareMatch = await matchesMiddleware({\n      asPath: asPath,\n      locale: locale,\n      router: this\n    });\n    if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith('/')) {\n      let rewrites;\n      ({\n        __rewrites: rewrites\n      } = await (0, _routeloader.getClientBuildManifest)());\n      const rewritesResult = (0, _resolverewrites.default)((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, this.locale), true), pages, rewrites, parsed.query, p => resolveDynamicRoute(p, pages), this.locales);\n      if (rewritesResult.externalDest) {\n        return;\n      }\n      if (!isMiddlewareMatch) {\n        resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), this.locale);\n      }\n      if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n        // if this directly matches a page we need to update the href to\n        // allow the correct page chunk to be loaded\n        pathname = rewritesResult.resolvedHref;\n        parsed.pathname = pathname;\n        if (!isMiddlewareMatch) {\n          url = (0, _formaturl.formatWithValidation)(parsed);\n        }\n      }\n    }\n    parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n    if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n      pathname = parsed.pathname;\n      parsed.pathname = pathname;\n      Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n      if (!isMiddlewareMatch) {\n        url = (0, _formaturl.formatWithValidation)(parsed);\n      }\n    }\n    const data = process.env.__NEXT_MIDDLEWARE_PREFETCH === 'strict' ? null : await withMiddlewareEffects({\n      fetchData: () => fetchNextData({\n        dataHref: this.pageLoader.getDataHref({\n          href: (0, _formaturl.formatWithValidation)({\n            pathname: originalPathname,\n            query\n          }),\n          skipInterpolation: true,\n          asPath: resolvedAs,\n          locale\n        }),\n        hasMiddleware: true,\n        isServerRender: false,\n        parseJSON: true,\n        inflightCache: this.sdc,\n        persistCache: !this.isPreview,\n        isPrefetch: true\n      }),\n      asPath: asPath,\n      locale: locale,\n      router: this\n    });\n    /**\n    * If there was a rewrite we apply the effects of the rewrite on the\n    * current parameters for the prefetch.\n    */\n    if ((data == null ? void 0 : data.effect.type) === 'rewrite') {\n      parsed.pathname = data.effect.resolvedHref;\n      pathname = data.effect.resolvedHref;\n      query = {\n        ...query,\n        ...data.effect.parsedAs.query\n      };\n      resolvedAs = data.effect.parsedAs.pathname;\n      url = (0, _formaturl.formatWithValidation)(parsed);\n    }\n    /**\n    * If there is a redirect to an external destination then we don't have\n    * to prefetch content as it will be unused.\n    */\n    if ((data == null ? void 0 : data.effect.type) === 'redirect-external') {\n      return;\n    }\n    const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n    if (await this._bfl(asPath, resolvedAs, options.locale, true)) {\n      this.components[urlPathname] = {\n        __appRouter: true\n      };\n    }\n    await Promise.all([this.pageLoader._isSsg(route).then(isSsg => {\n      return isSsg ? fetchNextData({\n        dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : this.pageLoader.getDataHref({\n          href: url,\n          asPath: resolvedAs,\n          locale: locale\n        }),\n        isServerRender: false,\n        parseJSON: true,\n        inflightCache: this.sdc,\n        persistCache: !this.isPreview,\n        isPrefetch: true,\n        unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!process.env.__NEXT_OPTIMISTIC_CLIENT_CACHE\n      }).then(() => false).catch(() => false) : false;\n    }), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);\n  }\n  async fetchComponent(route) {\n    const handleCancelled = getCancelledHandler({\n      route,\n      router: this\n    });\n    try {\n      const componentResult = await this.pageLoader.loadPage(route);\n      handleCancelled();\n      return componentResult;\n    } catch (err) {\n      handleCancelled();\n      throw err;\n    }\n  }\n  _getData(fn) {\n    let cancelled = false;\n    const cancel = () => {\n      cancelled = true;\n    };\n    this.clc = cancel;\n    return fn().then(data => {\n      if (cancel === this.clc) {\n        this.clc = null;\n      }\n      if (cancelled) {\n        const err = Object.defineProperty(new Error('Loading initial props cancelled'), \"__NEXT_ERROR_CODE\", {\n          value: \"E405\",\n          enumerable: false,\n          configurable: true\n        });\n        err.cancelled = true;\n        throw err;\n      }\n      return data;\n    });\n  }\n  getInitialProps(Component, ctx) {\n    const {\n      Component: App\n    } = this.components['/_app'];\n    const AppTree = this._wrapApp(App);\n    ctx.AppTree = AppTree;\n    return (0, _utils.loadGetInitialProps)(App, {\n      AppTree,\n      Component,\n      router: this,\n      ctx\n    });\n  }\n  get route() {\n    return this.state.route;\n  }\n  get pathname() {\n    return this.state.pathname;\n  }\n  get query() {\n    return this.state.query;\n  }\n  get asPath() {\n    return this.state.asPath;\n  }\n  get locale() {\n    return this.state.locale;\n  }\n  get isFallback() {\n    return this.state.isFallback;\n  }\n  get isPreview() {\n    return this.state.isPreview;\n  }\n  constructor(pathname, query, as, {\n    initialProps,\n    pageLoader,\n    App,\n    wrapApp,\n    Component,\n    err,\n    subscription,\n    isFallback,\n    locale,\n    locales,\n    defaultLocale,\n    domainLocales,\n    isPreview\n  }) {\n    // Server Data Cache (full data requests)\n    this.sdc = {};\n    // Server Background Cache (HEAD requests)\n    this.sbc = {};\n    this.isFirstPopStateEvent = true;\n    this._key = createKey();\n    this.onPopState = e => {\n      const {\n        isFirstPopStateEvent\n      } = this;\n      this.isFirstPopStateEvent = false;\n      const state = e.state;\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        const {\n          pathname,\n          query\n        } = this;\n        this.changeState('replaceState', (0, _formaturl.formatWithValidation)({\n          pathname: (0, _addbasepath.addBasePath)(pathname),\n          query\n        }), (0, _utils.getURL)());\n        return;\n      }\n      // __NA is used to identify if the history entry can be handled by the app-router.\n      if (state.__NA) {\n        window.location.reload();\n        return;\n      }\n      if (!state.__N) {\n        return;\n      }\n      // Safari fires popstateevent when reopening the browser.\n      if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {\n        return;\n      }\n      let forcedScroll;\n      const {\n        url,\n        as,\n        options,\n        key\n      } = state;\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          if (this._key !== key) {\n            // Snapshot current scroll position:\n            try {\n              sessionStorage.setItem('__next_scroll_' + this._key, JSON.stringify({\n                x: self.pageXOffset,\n                y: self.pageYOffset\n              }));\n            } catch (e) {}\n            // Restore old scroll position:\n            try {\n              const v = sessionStorage.getItem('__next_scroll_' + key);\n              forcedScroll = JSON.parse(v);\n            } catch (e) {\n              forcedScroll = {\n                x: 0,\n                y: 0\n              };\n            }\n          }\n        }\n      }\n      this._key = key;\n      const {\n        pathname\n      } = (0, _parserelativeurl.parseRelativeUrl)(url);\n      // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n      if (this.isSsr && as === (0, _addbasepath.addBasePath)(this.asPath) && pathname === (0, _addbasepath.addBasePath)(this.pathname)) {\n        return;\n      }\n      // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n      if (this._bps && !this._bps(state)) {\n        return;\n      }\n      this.change('replaceState', url, as, Object.assign({}, options, {\n        shallow: options.shallow && this._shallow,\n        locale: options.locale || this.defaultLocale,\n        // @ts-ignore internal value not exposed on types\n        _h: 0\n      }), forcedScroll);\n    };\n    // represents the current component key\n    const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n    // set up the component cache (by route keys)\n    this.components = {};\n    // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n    if (pathname !== '/_error') {\n      this.components[route] = {\n        Component,\n        initial: true,\n        props: initialProps,\n        err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP\n      };\n    }\n    this.components['/_app'] = {\n      Component: App,\n      styleSheets: []\n    };\n    // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n    this.events = Router.events;\n    this.pageLoader = pageLoader;\n    // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n    const autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n    this.basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp;\n    // make sure to ignore extra popState in safari on navigating\n    // back from external site\n    this.isSsr = true;\n    this.isLocaleDomain = false;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.isExperimentalCompile || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      this.locales = locales;\n      this.defaultLocale = defaultLocale;\n      this.domainLocales = domainLocales;\n      this.isLocaleDomain = !!(0, _detectdomainlocale.detectDomainLocale)(domainLocales, self.location.hostname);\n    }\n    this.state = {\n      route,\n      pathname,\n      query,\n      asPath: autoExportDynamic ? pathname : as,\n      isPreview: !!isPreview,\n      locale: process.env.__NEXT_I18N_SUPPORT ? locale : undefined,\n      isFallback\n    };\n    this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n    if (typeof window !== 'undefined') {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (!as.startsWith('//')) {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        const options = {\n          locale\n        };\n        const asPath = (0, _utils.getURL)();\n        this._initialMatchesMiddlewarePromise = matchesMiddleware({\n          router: this,\n          locale,\n          asPath\n        }).then(matches => {\n          // if middleware matches we leave resolving to the change function\n          // as the server needs to resolve for correct priority\n          ;\n          options._shouldResolveHref = as !== pathname;\n          this.changeState('replaceState', matches ? asPath : (0, _formaturl.formatWithValidation)({\n            pathname: (0, _addbasepath.addBasePath)(pathname),\n            query\n          }), asPath, options);\n          return matches;\n        });\n      }\n      window.addEventListener('popstate', this.onPopState);\n      // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          window.history.scrollRestoration = 'manual';\n        }\n      }\n    }\n  }\n}\nRouter.events = (0, _mitt.default)();","map":{"version":3,"names":["createKey","Router","matchesMiddleware","buildCancellationError","Object","assign","defineProperty","Error","cancelled","options","matchers","Promise","resolve","router","pageLoader","getMiddleware","pathname","asPathname","_parsepath","parsePath","asPath","cleanedAs","_hasbasepath","hasBasePath","_removebasepath","removeBasePath","asWithBasePathAndLocale","_addbasepath","addBasePath","_addlocale","addLocale","locale","some","m","RegExp","regexp","test","stripOrigin","url","origin","_utils","getLocationOrigin","startsWith","substring","length","prepareUrlAs","as","resolvedHref","resolvedAs","_resolvehref","resolveHref","hrefWasAbsolute","asWasAbsolute","preparedUrl","preparedAs","resolveDynamicRoute","pages","cleanPathname","_removetrailingslash","removeTrailingSlash","_denormalizepagepath","denormalizePagePath","includes","page","_isdynamic","isDynamicRoute","_routeregex","getRouteRegex","re","getMiddlewareData","source","response","nextConfig","basePath","i18n","locales","trailingSlash","Boolean","process","env","__NEXT_TRAILING_SLASH","rewriteHeader","headers","get","rewriteTarget","matchedPath","_constants","MATCHED_PATH_HEADER","__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE","parsedRewriteTarget","_parserelativeurl","parseRelativeUrl","pathnameInfo","_getnextpathnameinfo","getNextPathnameInfo","parseData","fsPathname","all","getPageList","_routeloader","getClientBuildManifest","then","param","__rewrites","rewrites","_normalizelocalepath","normalizeLocalePath","parsedSource","__NEXT_HAS_REWRITES","undefined","result","_resolverewrites","default","query","path","matchedPage","parsedAs","resolvedPathname","matches","_routematcher","getRouteMatcher","type","src","_formatnextpathnameinfo","formatNextPathnameInfo","defaultLocale","buildId","destination","hash","redirectTarget","newAs","newUrl","withMiddlewareEffects","fetchData","data","effect","dataHref","json","text","cacheKey","manualScrollRestoration","__NEXT_SCROLL_RESTORATION","window","history","v","sessionStorage","setItem","removeItem","n","SSG_DATA_NOT_FOUND","Symbol","fetchRetry","attempts","fetch","credentials","method","ok","status","tryToParseAsJSON","JSON","parse","error","fetchNextData","inflightCache","isPrefetch","hasMiddleware","isServerRender","parseJSON","persistCache","isBackground","unstable_skipClientCache","href","URL","location","getData","params","_params_method","purpose","NEXT_DEPLOYMENT_ID","_tryToParseAsJSON","notFound","markAssetError","NODE_ENV","catch","err","message","Math","random","toString","slice","handleHardNavigation","getCancelledHandler","route","cancel","clc","handleCancelled","reload","back","forward","push","_key","stringify","x","self","pageXOffset","y","pageYOffset","e","change","replace","_bfl","skipNavigate","__NEXT_CLIENT_ROUTER_FILTER_ENABLED","_bfl_s","_bfl_d","BloomFilter","require","staticFilterData","dynamicFilterData","__routerFilterStatic","__routerFilterDynamic","console","routerFilterSValue","__NEXT_CLIENT_ROUTER_S_FILTER","routerFilterDValue","__NEXT_CLIENT_ROUTER_D_FILTER","numHashes","numItems","errorRate","import","matchesBflStatic","matchesBflDynamic","pathsToCheck","curAs","allowMatchCurrent","asNoSlash","asNoSlashLocale","_this__bfl_s","_this__bfl_s1","contains","normalizedAS","curAsParts","split","i","_this__bfl_d","currentPart","join","forcedScroll","_this_components_pathname","_islocalurl","isLocalURL","isQueryUpdating","_h","shallow","shouldResolveHref","_shouldResolveHref","nextState","state","readyStateChange","isReady","isSsr","prevLocale","__NEXT_I18N_SUPPORT","localePathResult","detectedLocale","_formaturl","formatWithValidation","didNavigate","_this_locales","detectedDomain","_detectdomainlocale","detectDomainLocale","domainLocales","isLocaleDomain","hostname","domain","asNoBasePath","http","ST","performance","mark","scroll","routeProps","_inFlightRoute","events","emit","_removelocale","removeLocale","localeChange","onlyAHashChange","changeState","scrollToHash","set","components","_iserror","parsed","urlIsNew","parsedAsPathname","__appRouter","isMiddlewareRewrite","isMiddlewareMatch","rewritesResult","p","externalDest","routeMatch","routeRegex","shouldInterpolate","interpolatedAs","_interpolateas","interpolateAs","missingParams","keys","groups","filter","optional","warn","_omit","omit","isErrorRoute","_self___NEXT_DATA___props_pageProps","_self___NEXT_DATA___props","_routeInfo_props","routeInfo","getRouteInfo","isPreview","isFallback","cleanedParsedPathname","forEach","key","prefixedAs","rewriteAs","localeResult","curRouteMatch","component","Component","unstable_scriptLoader","scripts","concat","script","_script","handleClientScriptLoad","props","__N_SSG","__N_SSP","pageProps","__N_REDIRECT","__N_REDIRECT_BASE_PATH","parsedHref","__N_PREVIEW","notFoundRoute","fetchComponent","_","isNotFound","__NEXT_DATA__","statusCode","_routeInfo_route","isValidShallowRoute","_options_scroll","shouldScroll","resetScroll","upcomingScrollState","upcomingRouterState","_self___NEXT_DATA___props_pageProps1","_self___NEXT_DATA___props1","_routeInfo_props1","canSkipUpdating","_comparestates","compareRouterStates","document","documentElement","lang","hashRegex","getURL","_shallow","__N","handleRouteInfoError","loadErrorFail","isAssetError","styleSheets","getInitialProps","gipErr","routeInfoErr","requestedRoute","_data_effect","_data_effect1","_data_effect2","_data_response","existingInfo","cachedRouteInfo","fetchNextDataParams","getDataHref","skipInterpolation","sbc","sdc","resolvedRoute","_isapiroute","isAPIRoute","res","mod","isValidElementType","wasBailedPrefetch","shouldFetchData","_getData","fetched","getProperError","sub","beforePopState","cb","_bps","oldUrlNoHash","oldHash","newUrlNoHash","newHash","_handlesmoothscroll","handleSmoothScroll","scrollTo","rawHash","decodeURIComponent","idEl","getElementById","scrollIntoView","nameEl","getElementsByName","onlyHashChange","prefetch","_isbot","isBot","navigator","userAgent","urlPathname","originalPathname","__NEXT_MIDDLEWARE_PREFETCH","_isSsg","isSsg","priority","__NEXT_OPTIMISTIC_CLIENT_CACHE","componentResult","loadPage","fn","ctx","App","AppTree","_wrapApp","loadGetInitialProps","constructor","initialProps","wrapApp","subscription","isFirstPopStateEvent","onPopState","__NA","getItem","initial","autoExportDynamic","autoExport","__NEXT_ROUTER_BASEPATH","gssp","gip","isExperimentalCompile","appGip","gsp","search","_initialMatchesMiddlewarePromise","addEventListener","scrollRestoration","_mitt"],"sources":["C:\\Users\\богдан\\Desktop\\gobybus\\client\\node_modules\\next\\src\\shared\\lib\\router\\router.ts"],"sourcesContent":["// tslint:disable:no-console\nimport type { ComponentType } from 'react'\nimport type { DomainLocale } from '../../../server/config'\nimport type { MittEmitter } from '../mitt'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { RouterEvent } from '../../../client/router'\nimport type { StyleSheetTuple } from '../../../client/page-loader'\nimport type { UrlObject } from 'url'\nimport type PageLoader from '../../../client/page-loader'\nimport type { AppContextType, NextPageContext, NEXT_DATA } from '../utils'\nimport { removeTrailingSlash } from './utils/remove-trailing-slash'\nimport {\n  getClientBuildManifest,\n  isAssetError,\n  markAssetError,\n} from '../../../client/route-loader'\nimport { handleClientScriptLoad } from '../../../client/script'\nimport isError, { getProperError } from '../../../lib/is-error'\nimport { denormalizePagePath } from '../page-path/denormalize-page-path'\nimport { normalizeLocalePath } from '../i18n/normalize-locale-path'\nimport mitt from '../mitt'\nimport { getLocationOrigin, getURL, loadGetInitialProps, ST } from '../utils'\nimport { isDynamicRoute } from './utils/is-dynamic'\nimport { parseRelativeUrl } from './utils/parse-relative-url'\nimport resolveRewrites from './utils/resolve-rewrites'\nimport { getRouteMatcher } from './utils/route-matcher'\nimport { getRouteRegex } from './utils/route-regex'\nimport { formatWithValidation } from './utils/format-url'\nimport { detectDomainLocale } from '../../../client/detect-domain-locale'\nimport { parsePath } from './utils/parse-path'\nimport { addLocale } from '../../../client/add-locale'\nimport { removeLocale } from '../../../client/remove-locale'\nimport { removeBasePath } from '../../../client/remove-base-path'\nimport { addBasePath } from '../../../client/add-base-path'\nimport { hasBasePath } from '../../../client/has-base-path'\nimport { resolveHref } from '../../../client/resolve-href'\nimport { isAPIRoute } from '../../../lib/is-api-route'\nimport { getNextPathnameInfo } from './utils/get-next-pathname-info'\nimport { formatNextPathnameInfo } from './utils/format-next-pathname-info'\nimport { compareRouterStates } from './utils/compare-states'\nimport { isLocalURL } from './utils/is-local-url'\nimport { isBot } from './utils/is-bot'\nimport { omit } from './utils/omit'\nimport { interpolateAs } from './utils/interpolate-as'\nimport { handleSmoothScroll } from './utils/handle-smooth-scroll'\nimport type { Params } from '../../../server/request/params'\nimport { MATCHED_PATH_HEADER } from '../../../lib/constants'\n\ndeclare global {\n  interface Window {\n    /* prod */\n    __NEXT_DATA__: NEXT_DATA\n  }\n}\n\ninterface RouteProperties {\n  shallow: boolean\n}\n\ninterface TransitionOptions {\n  shallow?: boolean\n  locale?: string | false\n  scroll?: boolean\n  unstable_skipClientCache?: boolean\n}\n\ninterface NextHistoryState {\n  url: string\n  as: string\n  options: TransitionOptions\n}\n\nexport type HistoryState =\n  | null\n  | { __NA: true; __N?: false }\n  | { __N: false; __NA?: false }\n  | ({ __NA?: false; __N: true; key: string } & NextHistoryState)\n\nfunction buildCancellationError() {\n  return Object.assign(new Error('Route Cancelled'), {\n    cancelled: true,\n  })\n}\n\ninterface MiddlewareEffectParams<T extends FetchDataOutput> {\n  fetchData?: () => Promise<T>\n  locale?: string\n  asPath: string\n  router: Router\n}\n\nexport async function matchesMiddleware<T extends FetchDataOutput>(\n  options: MiddlewareEffectParams<T>\n): Promise<boolean> {\n  const matchers = await Promise.resolve(\n    options.router.pageLoader.getMiddleware()\n  )\n  if (!matchers) return false\n\n  const { pathname: asPathname } = parsePath(options.asPath)\n  // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n  const cleanedAs = hasBasePath(asPathname)\n    ? removeBasePath(asPathname)\n    : asPathname\n  const asWithBasePathAndLocale = addBasePath(\n    addLocale(cleanedAs, options.locale)\n  )\n\n  // Check only path match on client. Matching \"has\" should be done on server\n  // where we can access more info such as headers, HttpOnly cookie, etc.\n  return matchers.some((m) =>\n    new RegExp(m.regexp).test(asWithBasePathAndLocale)\n  )\n}\n\nfunction stripOrigin(url: string) {\n  const origin = getLocationOrigin()\n\n  return url.startsWith(origin) ? url.substring(origin.length) : url\n}\n\nfunction prepareUrlAs(router: NextRouter, url: Url, as?: Url) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  let [resolvedHref, resolvedAs] = resolveHref(router, url, true)\n  const origin = getLocationOrigin()\n  const hrefWasAbsolute = resolvedHref.startsWith(origin)\n  const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin)\n\n  resolvedHref = stripOrigin(resolvedHref)\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs\n\n  const preparedUrl = hrefWasAbsolute ? resolvedHref : addBasePath(resolvedHref)\n  const preparedAs = as\n    ? stripOrigin(resolveHref(router, as))\n    : resolvedAs || resolvedHref\n\n  return {\n    url: preparedUrl,\n    as: asWasAbsolute ? preparedAs : addBasePath(preparedAs),\n  }\n}\n\nfunction resolveDynamicRoute(pathname: string, pages: string[]) {\n  const cleanPathname = removeTrailingSlash(denormalizePagePath(pathname))\n  if (cleanPathname === '/404' || cleanPathname === '/_error') {\n    return pathname\n  }\n\n  // handle resolving href for dynamic routes\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some((page) => {\n      if (isDynamicRoute(page) && getRouteRegex(page).re.test(cleanPathname)) {\n        pathname = page\n        return true\n      }\n    })\n  }\n  return removeTrailingSlash(pathname)\n}\n\nfunction getMiddlewareData<T extends FetchDataOutput>(\n  source: string,\n  response: Response,\n  options: MiddlewareEffectParams<T>\n) {\n  const nextConfig = {\n    basePath: options.router.basePath,\n    i18n: { locales: options.router.locales },\n    trailingSlash: Boolean(process.env.__NEXT_TRAILING_SLASH),\n  }\n  const rewriteHeader = response.headers.get('x-nextjs-rewrite')\n\n  let rewriteTarget =\n    rewriteHeader || response.headers.get('x-nextjs-matched-path')\n\n  const matchedPath = response.headers.get(MATCHED_PATH_HEADER)\n\n  if (\n    matchedPath &&\n    !rewriteTarget &&\n    !matchedPath.includes('__next_data_catchall') &&\n    !matchedPath.includes('/_error') &&\n    !matchedPath.includes('/404')\n  ) {\n    // leverage x-matched-path to detect next.config.js rewrites\n    rewriteTarget = matchedPath\n  }\n\n  if (rewriteTarget) {\n    if (\n      rewriteTarget.startsWith('/') ||\n      process.env.__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE\n    ) {\n      const parsedRewriteTarget = parseRelativeUrl(rewriteTarget)\n      const pathnameInfo = getNextPathnameInfo(parsedRewriteTarget.pathname, {\n        nextConfig,\n        parseData: true,\n      })\n\n      let fsPathname = removeTrailingSlash(pathnameInfo.pathname)\n      return Promise.all([\n        options.router.pageLoader.getPageList(),\n        getClientBuildManifest(),\n      ]).then(([pages, { __rewrites: rewrites }]: any) => {\n        let as = addLocale(pathnameInfo.pathname, pathnameInfo.locale)\n\n        if (\n          isDynamicRoute(as) ||\n          (!rewriteHeader &&\n            pages.includes(\n              normalizeLocalePath(removeBasePath(as), options.router.locales)\n                .pathname\n            ))\n        ) {\n          const parsedSource = getNextPathnameInfo(\n            parseRelativeUrl(source).pathname,\n            {\n              nextConfig: process.env.__NEXT_HAS_REWRITES\n                ? undefined\n                : nextConfig,\n              parseData: true,\n            }\n          )\n\n          as = addBasePath(parsedSource.pathname)\n          parsedRewriteTarget.pathname = as\n        }\n\n        if (process.env.__NEXT_HAS_REWRITES) {\n          const result = resolveRewrites(\n            as,\n            pages,\n            rewrites,\n            parsedRewriteTarget.query,\n            (path: string) => resolveDynamicRoute(path, pages),\n            options.router.locales\n          )\n\n          if (result.matchedPage) {\n            parsedRewriteTarget.pathname = result.parsedAs.pathname\n            as = parsedRewriteTarget.pathname\n            Object.assign(parsedRewriteTarget.query, result.parsedAs.query)\n          }\n        } else if (!pages.includes(fsPathname)) {\n          const resolvedPathname = resolveDynamicRoute(fsPathname, pages)\n\n          if (resolvedPathname !== fsPathname) {\n            fsPathname = resolvedPathname\n          }\n        }\n\n        const resolvedHref = !pages.includes(fsPathname)\n          ? resolveDynamicRoute(\n              normalizeLocalePath(\n                removeBasePath(parsedRewriteTarget.pathname),\n                options.router.locales\n              ).pathname,\n              pages\n            )\n          : fsPathname\n\n        if (isDynamicRoute(resolvedHref)) {\n          const matches = getRouteMatcher(getRouteRegex(resolvedHref))(as)\n          Object.assign(parsedRewriteTarget.query, matches || {})\n        }\n\n        return {\n          type: 'rewrite' as const,\n          parsedAs: parsedRewriteTarget,\n          resolvedHref,\n        }\n      })\n    }\n    const src = parsePath(source)\n    const pathname = formatNextPathnameInfo({\n      ...getNextPathnameInfo(src.pathname, { nextConfig, parseData: true }),\n      defaultLocale: options.router.defaultLocale,\n      buildId: '',\n    })\n\n    return Promise.resolve({\n      type: 'redirect-external' as const,\n      destination: `${pathname}${src.query}${src.hash}`,\n    })\n  }\n\n  const redirectTarget = response.headers.get('x-nextjs-redirect')\n\n  if (redirectTarget) {\n    if (redirectTarget.startsWith('/')) {\n      const src = parsePath(redirectTarget)\n      const pathname = formatNextPathnameInfo({\n        ...getNextPathnameInfo(src.pathname, { nextConfig, parseData: true }),\n        defaultLocale: options.router.defaultLocale,\n        buildId: '',\n      })\n\n      return Promise.resolve({\n        type: 'redirect-internal' as const,\n        newAs: `${pathname}${src.query}${src.hash}`,\n        newUrl: `${pathname}${src.query}${src.hash}`,\n      })\n    }\n\n    return Promise.resolve({\n      type: 'redirect-external' as const,\n      destination: redirectTarget,\n    })\n  }\n\n  return Promise.resolve({ type: 'next' as const })\n}\n\ninterface WithMiddlewareEffectsOutput extends FetchDataOutput {\n  effect: Awaited<ReturnType<typeof getMiddlewareData>>\n}\n\nasync function withMiddlewareEffects<T extends FetchDataOutput>(\n  options: MiddlewareEffectParams<T>\n): Promise<WithMiddlewareEffectsOutput | null> {\n  const matches = await matchesMiddleware(options)\n  if (!matches || !options.fetchData) {\n    return null\n  }\n\n  const data = await options.fetchData()\n\n  const effect = await getMiddlewareData(data.dataHref, data.response, options)\n\n  return {\n    dataHref: data.dataHref,\n    json: data.json,\n    response: data.response,\n    text: data.text,\n    cacheKey: data.cacheKey,\n    effect,\n  }\n}\n\nexport type Url = UrlObject | string\n\nexport type BaseRouter = {\n  route: string\n  pathname: string\n  query: ParsedUrlQuery\n  asPath: string\n  basePath: string\n  locale?: string | undefined\n  locales?: readonly string[] | undefined\n  defaultLocale?: string | undefined\n  domainLocales?: readonly DomainLocale[] | undefined\n  isLocaleDomain: boolean\n}\n\nexport type NextRouter = BaseRouter &\n  Pick<\n    Router,\n    | 'push'\n    | 'replace'\n    | 'reload'\n    | 'back'\n    | 'forward'\n    | 'prefetch'\n    | 'beforePopState'\n    | 'events'\n    | 'isFallback'\n    | 'isReady'\n    | 'isPreview'\n  >\n\nexport type PrefetchOptions = {\n  priority?: boolean\n  locale?: string | false\n  unstable_skipClientCache?: boolean\n}\n\nexport type PrivateRouteInfo =\n  | (Omit<CompletePrivateRouteInfo, 'styleSheets'> & { initial: true })\n  | CompletePrivateRouteInfo\n\nexport type CompletePrivateRouteInfo = {\n  Component: ComponentType\n  styleSheets: StyleSheetTuple[]\n  __N_SSG?: boolean\n  __N_SSP?: boolean\n  props?: Record<string, any>\n  err?: Error\n  error?: any\n  route?: string\n  resolvedAs?: string\n  query?: ParsedUrlQuery\n}\n\nexport type AppProps = Pick<CompletePrivateRouteInfo, 'Component' | 'err'> & {\n  router: Router\n} & Record<string, any>\nexport type AppComponent = ComponentType<AppProps>\n\ntype Subscription = (\n  data: PrivateRouteInfo,\n  App: AppComponent,\n  resetScroll: { x: number; y: number } | null\n) => Promise<void>\n\ntype BeforePopStateCallback = (state: NextHistoryState) => boolean\n\ntype ComponentLoadCancel = (() => void) | null\n\ntype HistoryMethod = 'replaceState' | 'pushState'\n\nconst manualScrollRestoration =\n  process.env.__NEXT_SCROLL_RESTORATION &&\n  typeof window !== 'undefined' &&\n  'scrollRestoration' in window.history &&\n  !!(function () {\n    try {\n      let v = '__next'\n      // eslint-disable-next-line no-sequences\n      return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true\n    } catch (n) {}\n  })()\n\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND')\n\nfunction fetchRetry(\n  url: string,\n  attempts: number,\n  options: Pick<RequestInit, 'method' | 'headers'>\n): Promise<Response> {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` won’t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: 'same-origin',\n    method: options.method || 'GET',\n    headers: Object.assign({}, options.headers, {\n      'x-nextjs-data': '1',\n    }),\n  }).then((response) => {\n    return !response.ok && attempts > 1 && response.status >= 500\n      ? fetchRetry(url, attempts - 1, options)\n      : response\n  })\n}\n\ninterface FetchDataOutput {\n  dataHref: string\n  json: Record<string, any> | null\n  response: Response\n  text: string\n  cacheKey: string\n}\n\ninterface FetchNextDataParams {\n  dataHref: string\n  isServerRender: boolean\n  parseJSON: boolean | undefined\n  hasMiddleware?: boolean\n  inflightCache: NextDataCache\n  persistCache: boolean\n  isPrefetch: boolean\n  isBackground?: boolean\n  unstable_skipClientCache?: boolean\n}\n\nfunction tryToParseAsJSON(text: string) {\n  try {\n    return JSON.parse(text)\n  } catch (error) {\n    return null\n  }\n}\n\nfunction fetchNextData({\n  dataHref,\n  inflightCache,\n  isPrefetch,\n  hasMiddleware,\n  isServerRender,\n  parseJSON,\n  persistCache,\n  isBackground,\n  unstable_skipClientCache,\n}: FetchNextDataParams): Promise<FetchDataOutput> {\n  const { href: cacheKey } = new URL(dataHref, window.location.href)\n  const getData = (params?: { method?: 'HEAD' | 'GET' }) =>\n    fetchRetry(dataHref, isServerRender ? 3 : 1, {\n      headers: Object.assign(\n        {} as HeadersInit,\n        isPrefetch ? { purpose: 'prefetch' } : {},\n        isPrefetch && hasMiddleware ? { 'x-middleware-prefetch': '1' } : {},\n        process.env.NEXT_DEPLOYMENT_ID\n          ? { 'x-deployment-id': process.env.NEXT_DEPLOYMENT_ID }\n          : {}\n      ),\n      method: params?.method ?? 'GET',\n    })\n      .then((response) => {\n        if (response.ok && params?.method === 'HEAD') {\n          return { dataHref, response, text: '', json: {}, cacheKey }\n        }\n\n        return response.text().then((text) => {\n          if (!response.ok) {\n            /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */\n            if (\n              hasMiddleware &&\n              [301, 302, 307, 308].includes(response.status)\n            ) {\n              return { dataHref, response, text, json: {}, cacheKey }\n            }\n\n            if (response.status === 404) {\n              if (tryToParseAsJSON(text)?.notFound) {\n                return {\n                  dataHref,\n                  json: { notFound: SSG_DATA_NOT_FOUND },\n                  response,\n                  text,\n                  cacheKey,\n                }\n              }\n            }\n\n            const error = new Error(`Failed to load static props`)\n\n            /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */\n            if (!isServerRender) {\n              markAssetError(error)\n            }\n\n            throw error\n          }\n\n          return {\n            dataHref,\n            json: parseJSON ? tryToParseAsJSON(text) : null,\n            response,\n            text,\n            cacheKey,\n          }\n        })\n      })\n      .then((data) => {\n        if (\n          !persistCache ||\n          process.env.NODE_ENV !== 'production' ||\n          data.response.headers.get('x-middleware-cache') === 'no-cache'\n        ) {\n          delete inflightCache[cacheKey]\n        }\n        return data\n      })\n      .catch((err) => {\n        if (!unstable_skipClientCache) {\n          delete inflightCache[cacheKey]\n        }\n        if (\n          // chrome\n          err.message === 'Failed to fetch' ||\n          // firefox\n          err.message === 'NetworkError when attempting to fetch resource.' ||\n          // safari\n          err.message === 'Load failed'\n        ) {\n          markAssetError(err)\n        }\n        throw err\n      })\n\n  // when skipping client cache we wait to update\n  // inflight cache until successful data response\n  // this allows racing click event with fetching newer data\n  // without blocking navigation when stale data is available\n  if (unstable_skipClientCache && persistCache) {\n    return getData({}).then((data) => {\n      if (data.response.headers.get('x-middleware-cache') !== 'no-cache') {\n        // only update cache if not marked as no-cache\n        inflightCache[cacheKey] = Promise.resolve(data)\n      }\n\n      return data\n    })\n  }\n\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey]\n  }\n  return (inflightCache[cacheKey] = getData(\n    isBackground ? { method: 'HEAD' } : {}\n  ))\n}\n\ninterface NextDataCache {\n  [asPath: string]: Promise<FetchDataOutput>\n}\n\nexport function createKey() {\n  return Math.random().toString(36).slice(2, 10)\n}\n\nfunction handleHardNavigation({\n  url,\n  router,\n}: {\n  url: string\n  router: Router\n}) {\n  // ensure we don't trigger a hard navigation to the same\n  // URL as this can end up with an infinite refresh\n  if (url === addBasePath(addLocale(router.asPath, router.locale))) {\n    throw new Error(\n      `Invariant: attempted to hard navigate to the same URL ${url} ${location.href}`\n    )\n  }\n  window.location.href = url\n}\n\nconst getCancelledHandler = ({\n  route,\n  router,\n}: {\n  route: string\n  router: Router\n}) => {\n  let cancelled = false\n  const cancel = (router.clc = () => {\n    cancelled = true\n  })\n\n  const handleCancelled = () => {\n    if (cancelled) {\n      const error: any = new Error(\n        `Abort fetching component for route: \"${route}\"`\n      )\n      error.cancelled = true\n      throw error\n    }\n\n    if (cancel === router.clc) {\n      router.clc = null\n    }\n  }\n  return handleCancelled\n}\n\nexport default class Router implements BaseRouter {\n  basePath: string\n\n  /**\n   * Map of all components loaded in `Router`\n   */\n  components: { [pathname: string]: PrivateRouteInfo }\n  // Server Data Cache (full data requests)\n  sdc: NextDataCache = {}\n  // Server Background Cache (HEAD requests)\n  sbc: NextDataCache = {}\n\n  sub: Subscription\n  clc: ComponentLoadCancel\n  pageLoader: PageLoader\n  _bps: BeforePopStateCallback | undefined\n  events: MittEmitter<RouterEvent>\n  _wrapApp: (App: AppComponent) => any\n  isSsr: boolean\n  _inFlightRoute?: string | undefined\n  _shallow?: boolean | undefined\n  locales?: readonly string[] | undefined\n  defaultLocale?: string | undefined\n  domainLocales?: readonly DomainLocale[] | undefined\n  isReady: boolean\n  isLocaleDomain: boolean\n  isFirstPopStateEvent = true\n  _initialMatchesMiddlewarePromise: Promise<boolean>\n  // static entries filter\n  _bfl_s?: import('../../lib/bloom-filter').BloomFilter\n  // dynamic entires filter\n  _bfl_d?: import('../../lib/bloom-filter').BloomFilter\n\n  private state: Readonly<{\n    route: string\n    pathname: string\n    query: ParsedUrlQuery\n    asPath: string\n    locale: string | undefined\n    isFallback: boolean\n    isPreview: boolean\n  }>\n\n  private _key: string = createKey()\n\n  static events: MittEmitter<RouterEvent> = mitt()\n\n  constructor(\n    pathname: string,\n    query: ParsedUrlQuery,\n    as: string,\n    {\n      initialProps,\n      pageLoader,\n      App,\n      wrapApp,\n      Component,\n      err,\n      subscription,\n      isFallback,\n      locale,\n      locales,\n      defaultLocale,\n      domainLocales,\n      isPreview,\n    }: {\n      subscription: Subscription\n      initialProps: any\n      pageLoader: any\n      Component: ComponentType\n      App: AppComponent\n      wrapApp: (WrapAppComponent: AppComponent) => any\n      err?: Error\n      isFallback: boolean\n      locale?: string\n      locales?: readonly string[]\n      defaultLocale?: string\n      domainLocales?: readonly DomainLocale[]\n      isPreview?: boolean\n    }\n  ) {\n    // represents the current component key\n    const route = removeTrailingSlash(pathname)\n\n    // set up the component cache (by route keys)\n    this.components = {}\n    // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n    if (pathname !== '/_error') {\n      this.components[route] = {\n        Component,\n        initial: true,\n        props: initialProps,\n        err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP,\n      }\n    }\n\n    this.components['/_app'] = {\n      Component: App as ComponentType,\n      styleSheets: [\n        /* /_app does not need its stylesheets managed */\n      ],\n    }\n\n    // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n    this.events = Router.events\n\n    this.pageLoader = pageLoader\n    // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n    const autoExportDynamic =\n      isDynamicRoute(pathname) && self.__NEXT_DATA__.autoExport\n\n    this.basePath = process.env.__NEXT_ROUTER_BASEPATH || ''\n    this.sub = subscription\n    this.clc = null\n    this._wrapApp = wrapApp\n    // make sure to ignore extra popState in safari on navigating\n    // back from external site\n    this.isSsr = true\n    this.isLocaleDomain = false\n    this.isReady = !!(\n      self.__NEXT_DATA__.gssp ||\n      self.__NEXT_DATA__.gip ||\n      self.__NEXT_DATA__.isExperimentalCompile ||\n      (self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp) ||\n      (!autoExportDynamic &&\n        !self.location.search &&\n        !process.env.__NEXT_HAS_REWRITES)\n    )\n\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      this.locales = locales\n      this.defaultLocale = defaultLocale\n      this.domainLocales = domainLocales\n      this.isLocaleDomain = !!detectDomainLocale(\n        domainLocales,\n        self.location.hostname\n      )\n    }\n\n    this.state = {\n      route,\n      pathname,\n      query,\n      asPath: autoExportDynamic ? pathname : as,\n      isPreview: !!isPreview,\n      locale: process.env.__NEXT_I18N_SUPPORT ? locale : undefined,\n      isFallback,\n    }\n\n    this._initialMatchesMiddlewarePromise = Promise.resolve(false)\n\n    if (typeof window !== 'undefined') {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (!as.startsWith('//')) {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        const options: TransitionOptions = { locale }\n        const asPath = getURL()\n\n        this._initialMatchesMiddlewarePromise = matchesMiddleware({\n          router: this,\n          locale,\n          asPath,\n        }).then((matches) => {\n          // if middleware matches we leave resolving to the change function\n          // as the server needs to resolve for correct priority\n          ;(options as any)._shouldResolveHref = as !== pathname\n\n          this.changeState(\n            'replaceState',\n            matches\n              ? asPath\n              : formatWithValidation({\n                  pathname: addBasePath(pathname),\n                  query,\n                }),\n            asPath,\n            options\n          )\n          return matches\n        })\n      }\n\n      window.addEventListener('popstate', this.onPopState)\n\n      // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          window.history.scrollRestoration = 'manual'\n        }\n      }\n    }\n  }\n\n  onPopState = (e: PopStateEvent): void => {\n    const { isFirstPopStateEvent } = this\n    this.isFirstPopStateEvent = false\n\n    const state = e.state as HistoryState\n\n    if (!state) {\n      // We get state as undefined for two reasons.\n      //  1. With older safari (< 8) and older chrome (< 34)\n      //  2. When the URL changed with #\n      //\n      // In the both cases, we don't need to proceed and change the route.\n      // (as it's already changed)\n      // But we can simply replace the state with the new changes.\n      // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n      // So, doing the following for (1) does no harm.\n      const { pathname, query } = this\n      this.changeState(\n        'replaceState',\n        formatWithValidation({ pathname: addBasePath(pathname), query }),\n        getURL()\n      )\n      return\n    }\n\n    // __NA is used to identify if the history entry can be handled by the app-router.\n    if (state.__NA) {\n      window.location.reload()\n      return\n    }\n\n    if (!state.__N) {\n      return\n    }\n\n    // Safari fires popstateevent when reopening the browser.\n    if (\n      isFirstPopStateEvent &&\n      this.locale === state.options.locale &&\n      state.as === this.asPath\n    ) {\n      return\n    }\n\n    let forcedScroll: { x: number; y: number } | undefined\n    const { url, as, options, key } = state\n    if (process.env.__NEXT_SCROLL_RESTORATION) {\n      if (manualScrollRestoration) {\n        if (this._key !== key) {\n          // Snapshot current scroll position:\n          try {\n            sessionStorage.setItem(\n              '__next_scroll_' + this._key,\n              JSON.stringify({ x: self.pageXOffset, y: self.pageYOffset })\n            )\n          } catch {}\n\n          // Restore old scroll position:\n          try {\n            const v = sessionStorage.getItem('__next_scroll_' + key)\n            forcedScroll = JSON.parse(v!)\n          } catch {\n            forcedScroll = { x: 0, y: 0 }\n          }\n        }\n      }\n    }\n    this._key = key\n\n    const { pathname } = parseRelativeUrl(url)\n\n    // Make sure we don't re-render on initial load,\n    // can be caused by navigating back from an external site\n    if (\n      this.isSsr &&\n      as === addBasePath(this.asPath) &&\n      pathname === addBasePath(this.pathname)\n    ) {\n      return\n    }\n\n    // If the downstream application returns falsy, return.\n    // They will then be responsible for handling the event.\n    if (this._bps && !this._bps(state)) {\n      return\n    }\n\n    this.change(\n      'replaceState',\n      url,\n      as,\n      Object.assign<{}, TransitionOptions, TransitionOptions>({}, options, {\n        shallow: options.shallow && this._shallow,\n        locale: options.locale || this.defaultLocale,\n        // @ts-ignore internal value not exposed on types\n        _h: 0,\n      }),\n      forcedScroll\n    )\n  }\n\n  reload(): void {\n    window.location.reload()\n  }\n\n  /**\n   * Go back in history\n   */\n  back() {\n    window.history.back()\n  }\n\n  /**\n   * Go forward in history\n   */\n  forward() {\n    window.history.forward()\n  }\n\n  /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */\n  push(url: Url, as?: Url, options: TransitionOptions = {}) {\n    if (process.env.__NEXT_SCROLL_RESTORATION) {\n      // TODO: remove in the future when we update history before route change\n      // is complete, as the popstate event should handle this capture.\n      if (manualScrollRestoration) {\n        try {\n          // Snapshot scroll position right before navigating to a new page:\n          sessionStorage.setItem(\n            '__next_scroll_' + this._key,\n            JSON.stringify({ x: self.pageXOffset, y: self.pageYOffset })\n          )\n        } catch {}\n      }\n    }\n    ;({ url, as } = prepareUrlAs(this, url, as))\n    return this.change('pushState', url, as, options)\n  }\n\n  /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */\n  replace(url: Url, as?: Url, options: TransitionOptions = {}) {\n    ;({ url, as } = prepareUrlAs(this, url, as))\n    return this.change('replaceState', url, as, options)\n  }\n\n  async _bfl(\n    as: string,\n    resolvedAs?: string,\n    locale?: string | false,\n    skipNavigate?: boolean\n  ) {\n    if (process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {\n      if (!this._bfl_s && !this._bfl_d) {\n        const { BloomFilter } =\n          require('../../lib/bloom-filter') as typeof import('../../lib/bloom-filter')\n\n        type Filter = ReturnType<\n          import('../../lib/bloom-filter').BloomFilter['export']\n        >\n        let staticFilterData: Filter | undefined\n        let dynamicFilterData: Filter | undefined\n\n        try {\n          ;({\n            __routerFilterStatic: staticFilterData,\n            __routerFilterDynamic: dynamicFilterData,\n          } = (await getClientBuildManifest()) as any as {\n            __routerFilterStatic?: Filter\n            __routerFilterDynamic?: Filter\n          })\n        } catch (err) {\n          // failed to load build manifest hard navigate\n          // to be safe\n          console.error(err)\n          if (skipNavigate) {\n            return true\n          }\n          handleHardNavigation({\n            url: addBasePath(\n              addLocale(as, locale || this.locale, this.defaultLocale)\n            ),\n            router: this,\n          })\n          return new Promise(() => {})\n        }\n\n        const routerFilterSValue: Filter | false = process.env\n          .__NEXT_CLIENT_ROUTER_S_FILTER as any\n\n        if (!staticFilterData && routerFilterSValue) {\n          staticFilterData = routerFilterSValue ? routerFilterSValue : undefined\n        }\n\n        const routerFilterDValue: Filter | false = process.env\n          .__NEXT_CLIENT_ROUTER_D_FILTER as any\n\n        if (!dynamicFilterData && routerFilterDValue) {\n          dynamicFilterData = routerFilterDValue\n            ? routerFilterDValue\n            : undefined\n        }\n\n        if (staticFilterData?.numHashes) {\n          this._bfl_s = new BloomFilter(\n            staticFilterData.numItems,\n            staticFilterData.errorRate\n          )\n          this._bfl_s.import(staticFilterData)\n        }\n\n        if (dynamicFilterData?.numHashes) {\n          this._bfl_d = new BloomFilter(\n            dynamicFilterData.numItems,\n            dynamicFilterData.errorRate\n          )\n          this._bfl_d.import(dynamicFilterData)\n        }\n      }\n\n      let matchesBflStatic = false\n      let matchesBflDynamic = false\n      const pathsToCheck: Array<{ as?: string; allowMatchCurrent?: boolean }> =\n        [{ as }, { as: resolvedAs }]\n\n      for (const { as: curAs, allowMatchCurrent } of pathsToCheck) {\n        if (curAs) {\n          const asNoSlash = removeTrailingSlash(\n            new URL(curAs, 'http://n').pathname\n          )\n          const asNoSlashLocale = addBasePath(\n            addLocale(asNoSlash, locale || this.locale)\n          )\n\n          if (\n            allowMatchCurrent ||\n            asNoSlash !==\n              removeTrailingSlash(new URL(this.asPath, 'http://n').pathname)\n          ) {\n            matchesBflStatic =\n              matchesBflStatic ||\n              !!this._bfl_s?.contains(asNoSlash) ||\n              !!this._bfl_s?.contains(asNoSlashLocale)\n\n            for (const normalizedAS of [asNoSlash, asNoSlashLocale]) {\n              // if any sub-path of as matches a dynamic filter path\n              // it should be hard navigated\n              const curAsParts = normalizedAS.split('/')\n              for (\n                let i = 0;\n                !matchesBflDynamic && i < curAsParts.length + 1;\n                i++\n              ) {\n                const currentPart = curAsParts.slice(0, i).join('/')\n                if (currentPart && this._bfl_d?.contains(currentPart)) {\n                  matchesBflDynamic = true\n                  break\n                }\n              }\n            }\n\n            // if the client router filter is matched then we trigger\n            // a hard navigation\n            if (matchesBflStatic || matchesBflDynamic) {\n              if (skipNavigate) {\n                return true\n              }\n              handleHardNavigation({\n                url: addBasePath(\n                  addLocale(as, locale || this.locale, this.defaultLocale)\n                ),\n                router: this,\n              })\n              return new Promise(() => {})\n            }\n          }\n        }\n      }\n    }\n    return false\n  }\n\n  private async change(\n    method: HistoryMethod,\n    url: string,\n    as: string,\n    options: TransitionOptions,\n    forcedScroll?: { x: number; y: number }\n  ): Promise<boolean> {\n    if (!isLocalURL(url)) {\n      handleHardNavigation({ url, router: this })\n      return false\n    }\n    // WARNING: `_h` is an internal option for handing Next.js client-side\n    // hydration. Your app should _never_ use this property. It may change at\n    // any time without notice.\n    const isQueryUpdating = (options as any)._h === 1\n\n    if (!isQueryUpdating && !options.shallow) {\n      await this._bfl(as, undefined, options.locale)\n    }\n\n    let shouldResolveHref =\n      isQueryUpdating ||\n      (options as any)._shouldResolveHref ||\n      parsePath(url).pathname === parsePath(as).pathname\n\n    const nextState = {\n      ...this.state,\n    }\n\n    // for static pages with query params in the URL we delay\n    // marking the router ready until after the query is updated\n    // or a navigation has occurred\n    const readyStateChange = this.isReady !== true\n    this.isReady = true\n    const isSsr = this.isSsr\n\n    if (!isQueryUpdating) {\n      this.isSsr = false\n    }\n\n    // if a route transition is already in progress before\n    // the query updating is triggered ignore query updating\n    if (isQueryUpdating && this.clc) {\n      return false\n    }\n\n    const prevLocale = nextState.locale\n\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      nextState.locale =\n        options.locale === false\n          ? this.defaultLocale\n          : options.locale || nextState.locale\n\n      if (typeof options.locale === 'undefined') {\n        options.locale = nextState.locale\n      }\n\n      const parsedAs = parseRelativeUrl(\n        hasBasePath(as) ? removeBasePath(as) : as\n      )\n      const localePathResult = normalizeLocalePath(\n        parsedAs.pathname,\n        this.locales\n      )\n\n      if (localePathResult.detectedLocale) {\n        nextState.locale = localePathResult.detectedLocale\n        parsedAs.pathname = addBasePath(parsedAs.pathname)\n        as = formatWithValidation(parsedAs)\n        url = addBasePath(\n          normalizeLocalePath(\n            hasBasePath(url) ? removeBasePath(url) : url,\n            this.locales\n          ).pathname\n        )\n      }\n      let didNavigate = false\n\n      // we need to wrap this in the env check again since regenerator runtime\n      // moves this on its own due to the return\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        // if the locale isn't configured hard navigate to show 404 page\n        if (!this.locales?.includes(nextState.locale!)) {\n          parsedAs.pathname = addLocale(parsedAs.pathname, nextState.locale)\n          handleHardNavigation({\n            url: formatWithValidation(parsedAs),\n            router: this,\n          })\n          // this was previously a return but was removed in favor\n          // of better dead code elimination with regenerator runtime\n          didNavigate = true\n        }\n      }\n\n      const detectedDomain = detectDomainLocale(\n        this.domainLocales,\n        undefined,\n        nextState.locale\n      )\n\n      // we need to wrap this in the env check again since regenerator runtime\n      // moves this on its own due to the return\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        // if we are navigating to a domain locale ensure we redirect to the\n        // correct domain\n        if (\n          !didNavigate &&\n          detectedDomain &&\n          this.isLocaleDomain &&\n          self.location.hostname !== detectedDomain.domain\n        ) {\n          const asNoBasePath = removeBasePath(as)\n          handleHardNavigation({\n            url: `http${detectedDomain.http ? '' : 's'}://${\n              detectedDomain.domain\n            }${addBasePath(\n              `${\n                nextState.locale === detectedDomain.defaultLocale\n                  ? ''\n                  : `/${nextState.locale}`\n              }${asNoBasePath === '/' ? '' : asNoBasePath}` || '/'\n            )}`,\n            router: this,\n          })\n          // this was previously a return but was removed in favor\n          // of better dead code elimination with regenerator runtime\n          didNavigate = true\n        }\n      }\n\n      if (didNavigate) {\n        return new Promise(() => {})\n      }\n    }\n\n    // marking route changes as a navigation start entry\n    if (ST) {\n      performance.mark('routeChange')\n    }\n\n    const { shallow = false, scroll = true } = options\n    const routeProps = { shallow }\n\n    if (this._inFlightRoute && this.clc) {\n      if (!isSsr) {\n        Router.events.emit(\n          'routeChangeError',\n          buildCancellationError(),\n          this._inFlightRoute,\n          routeProps\n        )\n      }\n      this.clc()\n      this.clc = null\n    }\n\n    as = addBasePath(\n      addLocale(\n        hasBasePath(as) ? removeBasePath(as) : as,\n        options.locale,\n        this.defaultLocale\n      )\n    )\n    const cleanedAs = removeLocale(\n      hasBasePath(as) ? removeBasePath(as) : as,\n      nextState.locale\n    )\n    this._inFlightRoute = as\n\n    const localeChange = prevLocale !== nextState.locale\n\n    // If the url change is only related to a hash change\n    // We should not proceed. We should only change the state.\n\n    if (!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange) {\n      nextState.asPath = cleanedAs\n      Router.events.emit('hashChangeStart', as, routeProps)\n      // TODO: do we need the resolved href when only a hash change?\n      this.changeState(method, url, as, {\n        ...options,\n        scroll: false,\n      })\n      if (scroll) {\n        this.scrollToHash(cleanedAs)\n      }\n      try {\n        await this.set(nextState, this.components[nextState.route], null)\n      } catch (err) {\n        if (isError(err) && err.cancelled) {\n          Router.events.emit('routeChangeError', err, cleanedAs, routeProps)\n        }\n        throw err\n      }\n\n      Router.events.emit('hashChangeComplete', as, routeProps)\n      return true\n    }\n\n    let parsed = parseRelativeUrl(url)\n    let { pathname, query } = parsed\n\n    // The build manifest needs to be loaded before auto-static dynamic pages\n    // get their query parameters to allow ensuring they can be parsed properly\n    // when rewritten to\n    let pages: string[], rewrites: any\n    try {\n      ;[pages, { __rewrites: rewrites }] = await Promise.all([\n        this.pageLoader.getPageList(),\n        getClientBuildManifest(),\n        this.pageLoader.getMiddleware(),\n      ])\n    } catch (err) {\n      // If we fail to resolve the page list or client-build manifest, we must\n      // do a server-side transition:\n      handleHardNavigation({ url: as, router: this })\n      return false\n    }\n\n    // If asked to change the current URL we should reload the current page\n    // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n    // We also need to set the method = replaceState always\n    // as this should not go into the history (That's how browsers work)\n    // We should compare the new asPath to the current asPath, not the url\n    if (!this.urlIsNew(cleanedAs) && !localeChange) {\n      method = 'replaceState'\n    }\n\n    // we need to resolve the as value using rewrites for dynamic SSG\n    // pages to allow building the data URL correctly\n    let resolvedAs = as\n\n    // url and as should always be prefixed with basePath by this\n    // point by either next/link or router.push/replace so strip the\n    // basePath from the pathname to match the pages dir 1-to-1\n    pathname = pathname\n      ? removeTrailingSlash(removeBasePath(pathname))\n      : pathname\n\n    let route = removeTrailingSlash(pathname)\n    const parsedAsPathname = as.startsWith('/') && parseRelativeUrl(as).pathname\n\n    // if we detected the path as app route during prefetching\n    // trigger hard navigation\n    if ((this.components[pathname] as any)?.__appRouter) {\n      handleHardNavigation({ url: as, router: this })\n      return new Promise(() => {})\n    }\n\n    const isMiddlewareRewrite = !!(\n      parsedAsPathname &&\n      route !== parsedAsPathname &&\n      (!isDynamicRoute(route) ||\n        !getRouteMatcher(getRouteRegex(route))(parsedAsPathname))\n    )\n\n    // we don't attempt resolve asPath when we need to execute\n    // middleware as the resolving will occur server-side\n    const isMiddlewareMatch =\n      !options.shallow &&\n      (await matchesMiddleware({\n        asPath: as,\n        locale: nextState.locale,\n        router: this,\n      }))\n\n    if (isQueryUpdating && isMiddlewareMatch) {\n      shouldResolveHref = false\n    }\n\n    if (shouldResolveHref && pathname !== '/_error') {\n      ;(options as any)._shouldResolveHref = true\n\n      if (process.env.__NEXT_HAS_REWRITES && as.startsWith('/')) {\n        const rewritesResult = resolveRewrites(\n          addBasePath(addLocale(cleanedAs, nextState.locale), true),\n          pages,\n          rewrites,\n          query,\n          (p: string) => resolveDynamicRoute(p, pages),\n          this.locales\n        )\n\n        if (rewritesResult.externalDest) {\n          handleHardNavigation({ url: as, router: this })\n          return true\n        }\n        if (!isMiddlewareMatch) {\n          resolvedAs = rewritesResult.asPath\n        }\n\n        if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n          // if this directly matches a page we need to update the href to\n          // allow the correct page chunk to be loaded\n          pathname = rewritesResult.resolvedHref\n          parsed.pathname = addBasePath(pathname)\n\n          if (!isMiddlewareMatch) {\n            url = formatWithValidation(parsed)\n          }\n        }\n      } else {\n        parsed.pathname = resolveDynamicRoute(pathname, pages)\n\n        if (parsed.pathname !== pathname) {\n          pathname = parsed.pathname\n          parsed.pathname = addBasePath(pathname)\n\n          if (!isMiddlewareMatch) {\n            url = formatWithValidation(parsed)\n          }\n        }\n      }\n    }\n\n    if (!isLocalURL(as)) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(\n          `Invalid href: \"${url}\" and as: \"${as}\", received relative href and external as` +\n            `\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`\n        )\n      }\n      handleHardNavigation({ url: as, router: this })\n      return false\n    }\n\n    resolvedAs = removeLocale(removeBasePath(resolvedAs), nextState.locale)\n\n    route = removeTrailingSlash(pathname)\n    let routeMatch: Params | false = false\n\n    if (isDynamicRoute(route)) {\n      const parsedAs = parseRelativeUrl(resolvedAs)\n      const asPathname = parsedAs.pathname\n\n      const routeRegex = getRouteRegex(route)\n      routeMatch = getRouteMatcher(routeRegex)(asPathname)\n      const shouldInterpolate = route === asPathname\n      const interpolatedAs = shouldInterpolate\n        ? interpolateAs(route, asPathname, query)\n        : ({} as { result: undefined; params: undefined })\n\n      if (!routeMatch || (shouldInterpolate && !interpolatedAs.result)) {\n        const missingParams = Object.keys(routeRegex.groups).filter(\n          (param) => !query[param] && !routeRegex.groups[param].optional\n        )\n\n        if (missingParams.length > 0 && !isMiddlewareMatch) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(\n              `${\n                shouldInterpolate\n                  ? `Interpolating href`\n                  : `Mismatching \\`as\\` and \\`href\\``\n              } failed to manually provide ` +\n                `the params: ${missingParams.join(\n                  ', '\n                )} in the \\`href\\`'s \\`query\\``\n            )\n          }\n\n          throw new Error(\n            (shouldInterpolate\n              ? `The provided \\`href\\` (${url}) value is missing query values (${missingParams.join(\n                  ', '\n                )}) to be interpolated properly. `\n              : `The provided \\`as\\` value (${asPathname}) is incompatible with the \\`href\\` value (${route}). `) +\n              `Read more: https://nextjs.org/docs/messages/${\n                shouldInterpolate\n                  ? 'href-interpolation-failed'\n                  : 'incompatible-href-as'\n              }`\n          )\n        }\n      } else if (shouldInterpolate) {\n        as = formatWithValidation(\n          Object.assign({}, parsedAs, {\n            pathname: interpolatedAs.result,\n            query: omit(query, interpolatedAs.params!),\n          })\n        )\n      } else {\n        // Merge params into `query`, overwriting any specified in search\n        Object.assign(query, routeMatch)\n      }\n    }\n\n    if (!isQueryUpdating) {\n      Router.events.emit('routeChangeStart', as, routeProps)\n    }\n\n    const isErrorRoute = this.pathname === '/404' || this.pathname === '/_error'\n\n    try {\n      let routeInfo = await this.getRouteInfo({\n        route,\n        pathname,\n        query,\n        as,\n        resolvedAs,\n        routeProps,\n        locale: nextState.locale,\n        isPreview: nextState.isPreview,\n        hasMiddleware: isMiddlewareMatch,\n        unstable_skipClientCache: options.unstable_skipClientCache,\n        isQueryUpdating: isQueryUpdating && !this.isFallback,\n        isMiddlewareRewrite,\n      })\n\n      if (!isQueryUpdating && !options.shallow) {\n        await this._bfl(\n          as,\n          'resolvedAs' in routeInfo ? routeInfo.resolvedAs : undefined,\n          nextState.locale\n        )\n      }\n\n      if ('route' in routeInfo && isMiddlewareMatch) {\n        pathname = routeInfo.route || route\n        route = pathname\n\n        if (!routeProps.shallow) {\n          query = Object.assign({}, routeInfo.query || {}, query)\n        }\n\n        const cleanedParsedPathname = hasBasePath(parsed.pathname)\n          ? removeBasePath(parsed.pathname)\n          : parsed.pathname\n\n        if (routeMatch && pathname !== cleanedParsedPathname) {\n          Object.keys(routeMatch).forEach((key) => {\n            if (routeMatch && query[key] === routeMatch[key]) {\n              delete query[key]\n            }\n          })\n        }\n\n        if (isDynamicRoute(pathname)) {\n          const prefixedAs =\n            !routeProps.shallow && routeInfo.resolvedAs\n              ? routeInfo.resolvedAs\n              : addBasePath(\n                  addLocale(\n                    new URL(as, location.href).pathname,\n                    nextState.locale\n                  ),\n                  true\n                )\n\n          let rewriteAs = prefixedAs\n\n          if (hasBasePath(rewriteAs)) {\n            rewriteAs = removeBasePath(rewriteAs)\n          }\n\n          if (process.env.__NEXT_I18N_SUPPORT) {\n            const localeResult = normalizeLocalePath(rewriteAs, this.locales)\n            nextState.locale = localeResult.detectedLocale || nextState.locale\n            rewriteAs = localeResult.pathname\n          }\n          const routeRegex = getRouteRegex(pathname)\n          const curRouteMatch = getRouteMatcher(routeRegex)(\n            new URL(rewriteAs, location.href).pathname\n          )\n\n          if (curRouteMatch) {\n            Object.assign(query, curRouteMatch)\n          }\n        }\n      }\n\n      // If the routeInfo brings a redirect we simply apply it.\n      if ('type' in routeInfo) {\n        if (routeInfo.type === 'redirect-internal') {\n          return this.change(method, routeInfo.newUrl, routeInfo.newAs, options)\n        } else {\n          handleHardNavigation({ url: routeInfo.destination, router: this })\n          return new Promise(() => {})\n        }\n      }\n\n      const component: any = routeInfo.Component\n      if (component && component.unstable_scriptLoader) {\n        const scripts = [].concat(component.unstable_scriptLoader())\n\n        scripts.forEach((script: any) => {\n          handleClientScriptLoad(script.props)\n        })\n      }\n\n      // handle redirect on client-transition\n      if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {\n        if (\n          routeInfo.props.pageProps &&\n          routeInfo.props.pageProps.__N_REDIRECT\n        ) {\n          // Use the destination from redirect without adding locale\n          options.locale = false\n\n          const destination = routeInfo.props.pageProps.__N_REDIRECT\n\n          // check if destination is internal (resolves to a page) and attempt\n          // client-navigation if it is falling back to hard navigation if\n          // it's not\n          if (\n            destination.startsWith('/') &&\n            routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false\n          ) {\n            const parsedHref = parseRelativeUrl(destination)\n            parsedHref.pathname = resolveDynamicRoute(\n              parsedHref.pathname,\n              pages\n            )\n\n            const { url: newUrl, as: newAs } = prepareUrlAs(\n              this,\n              destination,\n              destination\n            )\n            return this.change(method, newUrl, newAs, options)\n          }\n          handleHardNavigation({ url: destination, router: this })\n          return new Promise(() => {})\n        }\n\n        nextState.isPreview = !!routeInfo.props.__N_PREVIEW\n\n        // handle SSG data 404\n        if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {\n          let notFoundRoute\n\n          try {\n            await this.fetchComponent('/404')\n            notFoundRoute = '/404'\n          } catch (_) {\n            notFoundRoute = '/_error'\n          }\n\n          routeInfo = await this.getRouteInfo({\n            route: notFoundRoute,\n            pathname: notFoundRoute,\n            query,\n            as,\n            resolvedAs,\n            routeProps: { shallow: false },\n            locale: nextState.locale,\n            isPreview: nextState.isPreview,\n            isNotFound: true,\n          })\n\n          if ('type' in routeInfo) {\n            throw new Error(`Unexpected middleware effect on /404`)\n          }\n        }\n      }\n\n      if (\n        isQueryUpdating &&\n        this.pathname === '/_error' &&\n        self.__NEXT_DATA__.props?.pageProps?.statusCode === 500 &&\n        routeInfo.props?.pageProps\n      ) {\n        // ensure statusCode is still correct for static 500 page\n        // when updating query information\n        routeInfo.props.pageProps.statusCode = 500\n      }\n\n      // shallow routing is only allowed for same page URL changes.\n      const isValidShallowRoute =\n        options.shallow && nextState.route === (routeInfo.route ?? route)\n\n      const shouldScroll =\n        options.scroll ?? (!isQueryUpdating && !isValidShallowRoute)\n      const resetScroll = shouldScroll ? { x: 0, y: 0 } : null\n      const upcomingScrollState = forcedScroll ?? resetScroll\n\n      // the new state that the router gonna set\n      const upcomingRouterState = {\n        ...nextState,\n        route,\n        pathname,\n        query,\n        asPath: cleanedAs,\n        isFallback: false,\n      }\n\n      // When the page being rendered is the 404 page, we should only update the\n      // query parameters. Route changes here might add the basePath when it\n      // wasn't originally present. This is also why this block is before the\n      // below `changeState` call which updates the browser's history (changing\n      // the URL).\n      if (isQueryUpdating && isErrorRoute) {\n        routeInfo = await this.getRouteInfo({\n          route: this.pathname,\n          pathname: this.pathname,\n          query,\n          as,\n          resolvedAs,\n          routeProps: { shallow: false },\n          locale: nextState.locale,\n          isPreview: nextState.isPreview,\n          isQueryUpdating: isQueryUpdating && !this.isFallback,\n        })\n\n        if ('type' in routeInfo) {\n          throw new Error(`Unexpected middleware effect on ${this.pathname}`)\n        }\n\n        if (\n          this.pathname === '/_error' &&\n          self.__NEXT_DATA__.props?.pageProps?.statusCode === 500 &&\n          routeInfo.props?.pageProps\n        ) {\n          // ensure statusCode is still correct for static 500 page\n          // when updating query information\n          routeInfo.props.pageProps.statusCode = 500\n        }\n\n        try {\n          await this.set(upcomingRouterState, routeInfo, upcomingScrollState)\n        } catch (err) {\n          if (isError(err) && err.cancelled) {\n            Router.events.emit('routeChangeError', err, cleanedAs, routeProps)\n          }\n          throw err\n        }\n\n        return true\n      }\n\n      Router.events.emit('beforeHistoryChange', as, routeProps)\n      this.changeState(method, url, as, options)\n\n      // for query updates we can skip it if the state is unchanged and we don't\n      // need to scroll\n      // https://github.com/vercel/next.js/issues/37139\n      const canSkipUpdating =\n        isQueryUpdating &&\n        !upcomingScrollState &&\n        !readyStateChange &&\n        !localeChange &&\n        compareRouterStates(upcomingRouterState, this.state)\n\n      if (!canSkipUpdating) {\n        try {\n          await this.set(upcomingRouterState, routeInfo, upcomingScrollState)\n        } catch (e: any) {\n          if (e.cancelled) routeInfo.error = routeInfo.error || e\n          else throw e\n        }\n\n        if (routeInfo.error) {\n          if (!isQueryUpdating) {\n            Router.events.emit(\n              'routeChangeError',\n              routeInfo.error,\n              cleanedAs,\n              routeProps\n            )\n          }\n\n          throw routeInfo.error\n        }\n\n        if (process.env.__NEXT_I18N_SUPPORT) {\n          if (nextState.locale) {\n            document.documentElement.lang = nextState.locale\n          }\n        }\n\n        if (!isQueryUpdating) {\n          Router.events.emit('routeChangeComplete', as, routeProps)\n        }\n\n        // A hash mark # is the optional last part of a URL\n        const hashRegex = /#.+$/\n        if (shouldScroll && hashRegex.test(as)) {\n          this.scrollToHash(as)\n        }\n      }\n\n      return true\n    } catch (err) {\n      if (isError(err) && err.cancelled) {\n        return false\n      }\n      throw err\n    }\n  }\n\n  changeState(\n    method: HistoryMethod,\n    url: string,\n    as: string,\n    options: TransitionOptions = {}\n  ): void {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof window.history === 'undefined') {\n        console.error(`Warning: window.history is not available.`)\n        return\n      }\n\n      if (typeof window.history[method] === 'undefined') {\n        console.error(`Warning: window.history.${method} is not available`)\n        return\n      }\n    }\n\n    if (method !== 'pushState' || getURL() !== as) {\n      this._shallow = options.shallow\n      window.history[method](\n        {\n          url,\n          as,\n          options,\n          __N: true,\n          key: (this._key = method !== 'pushState' ? this._key : createKey()),\n        } as HistoryState,\n        // Most browsers currently ignores this parameter, although they may use it in the future.\n        // Passing the empty string here should be safe against future changes to the method.\n        // https://developer.mozilla.org/docs/Web/API/History/replaceState\n        '',\n        as\n      )\n    }\n  }\n\n  async handleRouteInfoError(\n    err: Error & { code?: any; cancelled?: boolean },\n    pathname: string,\n    query: ParsedUrlQuery,\n    as: string,\n    routeProps: RouteProperties,\n    loadErrorFail?: boolean\n  ): Promise<CompletePrivateRouteInfo> {\n    if (err.cancelled) {\n      // bubble up cancellation errors\n      throw err\n    }\n\n    if (isAssetError(err) || loadErrorFail) {\n      Router.events.emit('routeChangeError', err, as, routeProps)\n\n      // If we can't load the page it could be one of following reasons\n      //  1. Page doesn't exists\n      //  2. Page does exist in a different zone\n      //  3. Internal error while loading the page\n\n      // So, doing a hard reload is the proper way to deal with this.\n      handleHardNavigation({\n        url: as,\n        router: this,\n      })\n\n      // Changing the URL doesn't block executing the current code path.\n      // So let's throw a cancellation error stop the routing logic.\n      throw buildCancellationError()\n    }\n\n    console.error(err)\n\n    try {\n      let props: Record<string, any> | undefined\n      const { page: Component, styleSheets } =\n        await this.fetchComponent('/_error')\n\n      const routeInfo: CompletePrivateRouteInfo = {\n        props,\n        Component,\n        styleSheets,\n        err,\n        error: err,\n      }\n\n      if (!routeInfo.props) {\n        try {\n          routeInfo.props = await this.getInitialProps(Component, {\n            err,\n            pathname,\n            query,\n          } as any)\n        } catch (gipErr) {\n          console.error('Error in error page `getInitialProps`: ', gipErr)\n          routeInfo.props = {}\n        }\n      }\n\n      return routeInfo\n    } catch (routeInfoErr) {\n      return this.handleRouteInfoError(\n        isError(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + ''),\n        pathname,\n        query,\n        as,\n        routeProps,\n        true\n      )\n    }\n  }\n\n  async getRouteInfo({\n    route: requestedRoute,\n    pathname,\n    query,\n    as,\n    resolvedAs,\n    routeProps,\n    locale,\n    hasMiddleware,\n    isPreview,\n    unstable_skipClientCache,\n    isQueryUpdating,\n    isMiddlewareRewrite,\n    isNotFound,\n  }: {\n    route: string\n    pathname: string\n    query: ParsedUrlQuery\n    as: string\n    resolvedAs: string\n    hasMiddleware?: boolean\n    routeProps: RouteProperties\n    locale: string | undefined\n    isPreview: boolean\n    unstable_skipClientCache?: boolean\n    isQueryUpdating?: boolean\n    isMiddlewareRewrite?: boolean\n    isNotFound?: boolean\n  }) {\n    /**\n     * This `route` binding can change if there's a rewrite\n     * so we keep a reference to the original requested route\n     * so we can store the cache for it and avoid re-requesting every time\n     * for shallow routing purposes.\n     */\n    let route = requestedRoute\n\n    try {\n      let existingInfo: PrivateRouteInfo | undefined = this.components[route]\n      if (routeProps.shallow && existingInfo && this.route === route) {\n        return existingInfo\n      }\n\n      const handleCancelled = getCancelledHandler({ route, router: this })\n\n      if (hasMiddleware) {\n        existingInfo = undefined\n      }\n\n      let cachedRouteInfo =\n        existingInfo &&\n        !('initial' in existingInfo) &&\n        process.env.NODE_ENV !== 'development'\n          ? existingInfo\n          : undefined\n\n      const isBackground = isQueryUpdating\n      const fetchNextDataParams: FetchNextDataParams = {\n        dataHref: this.pageLoader.getDataHref({\n          href: formatWithValidation({ pathname, query }),\n          skipInterpolation: true,\n          asPath: isNotFound ? '/404' : resolvedAs,\n          locale,\n        }),\n        hasMiddleware: true,\n        isServerRender: this.isSsr,\n        parseJSON: true,\n        inflightCache: isBackground ? this.sbc : this.sdc,\n        persistCache: !isPreview,\n        isPrefetch: false,\n        unstable_skipClientCache,\n        isBackground,\n      }\n\n      let data:\n        | WithMiddlewareEffectsOutput\n        | (Pick<WithMiddlewareEffectsOutput, 'json'> &\n            Omit<Partial<WithMiddlewareEffectsOutput>, 'json'>)\n        | null =\n        isQueryUpdating && !isMiddlewareRewrite\n          ? null\n          : await withMiddlewareEffects({\n              fetchData: () => fetchNextData(fetchNextDataParams),\n              asPath: isNotFound ? '/404' : resolvedAs,\n              locale: locale,\n              router: this,\n            }).catch((err) => {\n              // we don't hard error during query updating\n              // as it's un-necessary and doesn't need to be fatal\n              // unless it is a fallback route and the props can't\n              // be loaded\n              if (isQueryUpdating) {\n                return null\n              }\n              throw err\n            })\n\n      // when rendering error routes we don't apply middleware\n      // effects\n      if (data && (pathname === '/_error' || pathname === '/404')) {\n        data.effect = undefined\n      }\n\n      if (isQueryUpdating) {\n        if (!data) {\n          data = { json: self.__NEXT_DATA__.props }\n        } else {\n          data.json = self.__NEXT_DATA__.props\n        }\n      }\n\n      handleCancelled()\n\n      if (\n        data?.effect?.type === 'redirect-internal' ||\n        data?.effect?.type === 'redirect-external'\n      ) {\n        return data.effect\n      }\n\n      if (data?.effect?.type === 'rewrite') {\n        const resolvedRoute = removeTrailingSlash(data.effect.resolvedHref)\n        const pages = await this.pageLoader.getPageList()\n\n        // during query updating the page must match although during\n        // client-transition a redirect that doesn't match a page\n        // can be returned and this should trigger a hard navigation\n        // which is valid for incremental migration\n        if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n          route = resolvedRoute\n          pathname = data.effect.resolvedHref\n          query = { ...query, ...data.effect.parsedAs.query }\n          resolvedAs = removeBasePath(\n            normalizeLocalePath(data.effect.parsedAs.pathname, this.locales)\n              .pathname\n          )\n\n          // Check again the cache with the new destination.\n          existingInfo = this.components[route]\n          if (\n            routeProps.shallow &&\n            existingInfo &&\n            this.route === route &&\n            !hasMiddleware\n          ) {\n            // If we have a match with the current route due to rewrite,\n            // we can copy the existing information to the rewritten one.\n            // Then, we return the information along with the matched route.\n            return { ...existingInfo, route }\n          }\n        }\n      }\n\n      if (isAPIRoute(route)) {\n        handleHardNavigation({ url: as, router: this })\n        return new Promise<never>(() => {})\n      }\n\n      const routeInfo =\n        cachedRouteInfo ||\n        (await this.fetchComponent(route).then<CompletePrivateRouteInfo>(\n          (res) => ({\n            Component: res.page,\n            styleSheets: res.styleSheets,\n            __N_SSG: res.mod.__N_SSG,\n            __N_SSP: res.mod.__N_SSP,\n          })\n        ))\n\n      if (process.env.NODE_ENV !== 'production') {\n        const { isValidElementType } = require('next/dist/compiled/react-is')\n        if (!isValidElementType(routeInfo.Component)) {\n          throw new Error(\n            `The default export is not a React Component in page: \"${pathname}\"`\n          )\n        }\n      }\n      const wasBailedPrefetch = data?.response?.headers.get('x-middleware-skip')\n\n      const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP\n\n      // For non-SSG prefetches that bailed before sending data\n      // we clear the cache to fetch full response\n      if (wasBailedPrefetch && data?.dataHref) {\n        delete this.sdc[data.dataHref]\n      }\n\n      const { props, cacheKey } = await this._getData(async () => {\n        if (shouldFetchData) {\n          if (data?.json && !wasBailedPrefetch) {\n            return { cacheKey: data.cacheKey, props: data.json }\n          }\n\n          const dataHref = data?.dataHref\n            ? data.dataHref\n            : this.pageLoader.getDataHref({\n                href: formatWithValidation({ pathname, query }),\n                asPath: resolvedAs,\n                locale,\n              })\n\n          const fetched = await fetchNextData({\n            dataHref,\n            isServerRender: this.isSsr,\n            parseJSON: true,\n            inflightCache: wasBailedPrefetch ? {} : this.sdc,\n            persistCache: !isPreview,\n            isPrefetch: false,\n            unstable_skipClientCache,\n          })\n\n          return {\n            cacheKey: fetched.cacheKey,\n            props: fetched.json || {},\n          }\n        }\n\n        return {\n          headers: {},\n          props: await this.getInitialProps(\n            routeInfo.Component,\n            // we provide AppTree later so this needs to be `any`\n            {\n              pathname,\n              query,\n              asPath: as,\n              locale,\n              locales: this.locales,\n              defaultLocale: this.defaultLocale,\n            } as any\n          ),\n        }\n      })\n\n      // Only bust the data cache for SSP routes although\n      // middleware can skip cache per request with\n      // x-middleware-cache: no-cache as well\n      if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n        delete this.sdc[cacheKey]\n      }\n\n      // we kick off a HEAD request in the background\n      // when a non-prefetch request is made to signal revalidation\n      if (\n        !this.isPreview &&\n        routeInfo.__N_SSG &&\n        process.env.NODE_ENV !== 'development' &&\n        !isQueryUpdating\n      ) {\n        fetchNextData(\n          Object.assign({}, fetchNextDataParams, {\n            isBackground: true,\n            persistCache: false,\n            inflightCache: this.sbc,\n          })\n        ).catch(() => {})\n      }\n\n      props.pageProps = Object.assign({}, props.pageProps)\n      routeInfo.props = props\n      routeInfo.route = route\n      routeInfo.query = query\n      routeInfo.resolvedAs = resolvedAs\n      this.components[route] = routeInfo\n\n      return routeInfo\n    } catch (err) {\n      return this.handleRouteInfoError(\n        getProperError(err),\n        pathname,\n        query,\n        as,\n        routeProps\n      )\n    }\n  }\n\n  private set(\n    state: typeof this.state,\n    data: PrivateRouteInfo,\n    resetScroll: { x: number; y: number } | null\n  ): Promise<void> {\n    this.state = state\n\n    return this.sub(\n      data,\n      this.components['/_app'].Component as AppComponent,\n      resetScroll\n    )\n  }\n\n  /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */\n  beforePopState(cb: BeforePopStateCallback) {\n    this._bps = cb\n  }\n\n  onlyAHashChange(as: string): boolean {\n    if (!this.asPath) return false\n    const [oldUrlNoHash, oldHash] = this.asPath.split('#', 2)\n    const [newUrlNoHash, newHash] = as.split('#', 2)\n\n    // Makes sure we scroll to the provided hash if the url/hash are the same\n    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n      return true\n    }\n\n    // If the urls are change, there's more than a hash change\n    if (oldUrlNoHash !== newUrlNoHash) {\n      return false\n    }\n\n    // If the hash has changed, then it's a hash only change.\n    // This check is necessary to handle both the enter and\n    // leave hash === '' cases. The identity case falls through\n    // and is treated as a next reload.\n    return oldHash !== newHash\n  }\n\n  scrollToHash(as: string): void {\n    const [, hash = ''] = as.split('#', 2)\n\n    handleSmoothScroll(\n      () => {\n        // Scroll to top if the hash is just `#` with no value or `#top`\n        // To mirror browsers\n        if (hash === '' || hash === 'top') {\n          window.scrollTo(0, 0)\n          return\n        }\n\n        // Decode hash to make non-latin anchor works.\n        const rawHash = decodeURIComponent(hash)\n        // First we check if the element by id is found\n        const idEl = document.getElementById(rawHash)\n        if (idEl) {\n          idEl.scrollIntoView()\n          return\n        }\n        // If there's no element with the id, we check the `name` property\n        // To mirror browsers\n        const nameEl = document.getElementsByName(rawHash)[0]\n        if (nameEl) {\n          nameEl.scrollIntoView()\n        }\n      },\n      {\n        onlyHashChange: this.onlyAHashChange(as),\n      }\n    )\n  }\n\n  urlIsNew(asPath: string): boolean {\n    return this.asPath !== asPath\n  }\n\n  /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */\n  async prefetch(\n    url: string,\n    asPath: string = url,\n    options: PrefetchOptions = {}\n  ): Promise<void> {\n    // Prefetch is not supported in development mode because it would trigger on-demand-entries\n    if (process.env.NODE_ENV !== 'production') {\n      return\n    }\n\n    if (typeof window !== 'undefined' && isBot(window.navigator.userAgent)) {\n      // No prefetches for bots that render the link since they are typically navigating\n      // links via the equivalent of a hard navigation and hence never utilize these\n      // prefetches.\n      return\n    }\n    let parsed = parseRelativeUrl(url)\n    const urlPathname = parsed.pathname\n\n    let { pathname, query } = parsed\n    const originalPathname = pathname\n\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      if (options.locale === false) {\n        pathname = normalizeLocalePath!(pathname, this.locales).pathname\n        parsed.pathname = pathname\n        url = formatWithValidation(parsed)\n\n        let parsedAs = parseRelativeUrl(asPath)\n        const localePathResult = normalizeLocalePath!(\n          parsedAs.pathname,\n          this.locales\n        )\n        parsedAs.pathname = localePathResult.pathname\n        options.locale = localePathResult.detectedLocale || this.defaultLocale\n        asPath = formatWithValidation(parsedAs)\n      }\n    }\n\n    const pages = await this.pageLoader.getPageList()\n    let resolvedAs = asPath\n\n    const locale =\n      typeof options.locale !== 'undefined'\n        ? options.locale || undefined\n        : this.locale\n\n    const isMiddlewareMatch = await matchesMiddleware({\n      asPath: asPath,\n      locale: locale,\n      router: this,\n    })\n\n    if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith('/')) {\n      let rewrites: any\n      ;({ __rewrites: rewrites } = await getClientBuildManifest())\n\n      const rewritesResult = resolveRewrites(\n        addBasePath(addLocale(asPath, this.locale), true),\n        pages,\n        rewrites,\n        parsed.query,\n        (p: string) => resolveDynamicRoute(p, pages),\n        this.locales\n      )\n\n      if (rewritesResult.externalDest) {\n        return\n      }\n\n      if (!isMiddlewareMatch) {\n        resolvedAs = removeLocale(\n          removeBasePath(rewritesResult.asPath),\n          this.locale\n        )\n      }\n\n      if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n        // if this directly matches a page we need to update the href to\n        // allow the correct page chunk to be loaded\n        pathname = rewritesResult.resolvedHref\n        parsed.pathname = pathname\n\n        if (!isMiddlewareMatch) {\n          url = formatWithValidation(parsed)\n        }\n      }\n    }\n    parsed.pathname = resolveDynamicRoute(parsed.pathname, pages)\n\n    if (isDynamicRoute(parsed.pathname)) {\n      pathname = parsed.pathname\n      parsed.pathname = pathname\n      Object.assign(\n        query,\n        getRouteMatcher(getRouteRegex(parsed.pathname))(\n          parsePath(asPath).pathname\n        ) || {}\n      )\n\n      if (!isMiddlewareMatch) {\n        url = formatWithValidation(parsed)\n      }\n    }\n\n    const data =\n      process.env.__NEXT_MIDDLEWARE_PREFETCH === 'strict'\n        ? null\n        : await withMiddlewareEffects({\n            fetchData: () =>\n              fetchNextData({\n                dataHref: this.pageLoader.getDataHref({\n                  href: formatWithValidation({\n                    pathname: originalPathname,\n                    query,\n                  }),\n                  skipInterpolation: true,\n                  asPath: resolvedAs,\n                  locale,\n                }),\n                hasMiddleware: true,\n                isServerRender: false,\n                parseJSON: true,\n                inflightCache: this.sdc,\n                persistCache: !this.isPreview,\n                isPrefetch: true,\n              }),\n            asPath: asPath,\n            locale: locale,\n            router: this,\n          })\n\n    /**\n     * If there was a rewrite we apply the effects of the rewrite on the\n     * current parameters for the prefetch.\n     */\n    if (data?.effect.type === 'rewrite') {\n      parsed.pathname = data.effect.resolvedHref\n      pathname = data.effect.resolvedHref\n      query = { ...query, ...data.effect.parsedAs.query }\n      resolvedAs = data.effect.parsedAs.pathname\n      url = formatWithValidation(parsed)\n    }\n\n    /**\n     * If there is a redirect to an external destination then we don't have\n     * to prefetch content as it will be unused.\n     */\n    if (data?.effect.type === 'redirect-external') {\n      return\n    }\n\n    const route = removeTrailingSlash(pathname)\n\n    if (await this._bfl(asPath, resolvedAs, options.locale, true)) {\n      this.components[urlPathname] = { __appRouter: true } as any\n    }\n\n    await Promise.all([\n      this.pageLoader._isSsg(route).then((isSsg) => {\n        return isSsg\n          ? fetchNextData({\n              dataHref: data?.json\n                ? data?.dataHref\n                : this.pageLoader.getDataHref({\n                    href: url,\n                    asPath: resolvedAs,\n                    locale: locale,\n                  }),\n              isServerRender: false,\n              parseJSON: true,\n              inflightCache: this.sdc,\n              persistCache: !this.isPreview,\n              isPrefetch: true,\n              unstable_skipClientCache:\n                options.unstable_skipClientCache ||\n                (options.priority &&\n                  !!process.env.__NEXT_OPTIMISTIC_CLIENT_CACHE),\n            })\n              .then(() => false)\n              .catch(() => false)\n          : false\n      }),\n      this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route),\n    ])\n  }\n\n  async fetchComponent(route: string) {\n    const handleCancelled = getCancelledHandler({ route, router: this })\n\n    try {\n      const componentResult = await this.pageLoader.loadPage(route)\n      handleCancelled()\n\n      return componentResult\n    } catch (err) {\n      handleCancelled()\n      throw err\n    }\n  }\n\n  _getData<T>(fn: () => Promise<T>): Promise<T> {\n    let cancelled = false\n    const cancel = () => {\n      cancelled = true\n    }\n    this.clc = cancel\n    return fn().then((data) => {\n      if (cancel === this.clc) {\n        this.clc = null\n      }\n\n      if (cancelled) {\n        const err: any = new Error('Loading initial props cancelled')\n        err.cancelled = true\n        throw err\n      }\n\n      return data\n    })\n  }\n\n  getInitialProps(\n    Component: ComponentType,\n    ctx: NextPageContext\n  ): Promise<Record<string, any>> {\n    const { Component: App } = this.components['/_app']\n    const AppTree = this._wrapApp(App as AppComponent)\n    ctx.AppTree = AppTree\n    return loadGetInitialProps<AppContextType<Router>>(App, {\n      AppTree,\n      Component,\n      router: this,\n      ctx,\n    })\n  }\n\n  get route(): string {\n    return this.state.route\n  }\n\n  get pathname(): string {\n    return this.state.pathname\n  }\n\n  get query(): ParsedUrlQuery {\n    return this.state.query\n  }\n\n  get asPath(): string {\n    return this.state.asPath\n  }\n\n  get locale(): string | undefined {\n    return this.state.locale\n  }\n\n  get isFallback(): boolean {\n    return this.state.isFallback\n  }\n\n  get isPreview(): boolean {\n    return this.state.isPreview\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}