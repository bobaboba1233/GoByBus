{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  createRouteLoader: null,\n  getClientBuildManifest: null,\n  isAssetError: null,\n  markAssetError: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  createRouteLoader: function () {\n    return createRouteLoader;\n  },\n  getClientBuildManifest: function () {\n    return getClientBuildManifest;\n  },\n  isAssetError: function () {\n    return isAssetError;\n  },\n  markAssetError: function () {\n    return markAssetError;\n  }\n});\nconst _interop_require_default = require(\"@swc/helpers/_/_interop_require_default\");\nconst _getassetpathfromroute = /*#__PURE__*/_interop_require_default._(require(\"../shared/lib/router/utils/get-asset-path-from-route\"));\nconst _trustedtypes = require(\"./trusted-types\");\nconst _requestidlecallback = require(\"./request-idle-callback\");\nconst _deploymentid = require(\"../build/deployment-id\");\nconst _encodeuripath = require(\"../shared/lib/encode-uri-path\");\n// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\nconst MS_MAX_IDLE_DELAY = 3800;\nfunction withFuture(key, map, generator) {\n  let entry = map.get(key);\n  if (entry) {\n    if ('future' in entry) {\n      return entry.future;\n    }\n    return Promise.resolve(entry);\n  }\n  let resolver;\n  const prom = new Promise(resolve => {\n    resolver = resolve;\n  });\n  map.set(key, {\n    resolve: resolver,\n    future: prom\n  });\n  return generator ? generator().then(value => {\n    resolver(value);\n    return value;\n  }).catch(err => {\n    map.delete(key);\n    throw err;\n  }) : prom;\n}\nconst ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR');\nfunction markAssetError(err) {\n  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});\n}\nfunction isAssetError(err) {\n  return err && ASSET_LOAD_ERROR in err;\n}\nfunction hasPrefetch(link) {\n  try {\n    link = document.createElement('link');\n    return (\n      // detect IE11 since it supports prefetch but isn't detected\n      // with relList.support\n      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')\n    );\n  } catch (e) {\n    return false;\n  }\n}\nconst canPrefetch = hasPrefetch();\nconst getAssetQueryString = () => {\n  return (0, _deploymentid.getDeploymentIdQueryOrEmptyString)();\n};\nfunction prefetchViaDom(href, as, link) {\n  return new Promise((resolve, reject) => {\n    const selector = '\\n      link[rel=\"prefetch\"][href^=\"' + href + '\"],\\n      link[rel=\"preload\"][href^=\"' + href + '\"],\\n      script[src^=\"' + href + '\"]';\n    if (document.querySelector(selector)) {\n      return resolve();\n    }\n    link = document.createElement('link');\n    // The order of property assignment here is intentional:\n    if (as) link.as = as;\n    link.rel = \"prefetch\";\n    link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    link.onload = resolve;\n    link.onerror = () => reject(markAssetError(Object.defineProperty(new Error(\"Failed to prefetch: \" + href), \"__NEXT_ERROR_CODE\", {\n      value: \"E268\",\n      enumerable: false,\n      configurable: true\n    })));\n    // `href` should always be last:\n    link.href = href;\n    document.head.appendChild(link);\n  });\n}\nfunction appendScript(src, script) {\n  return new Promise((resolve, reject) => {\n    script = document.createElement('script');\n    // The order of property assignment here is intentional.\n    // 1. Setup success/failure hooks in case the browser synchronously\n    //    executes when `src` is set.\n    script.onload = resolve;\n    script.onerror = () => reject(markAssetError(Object.defineProperty(new Error(\"Failed to load script: \" + src), \"__NEXT_ERROR_CODE\", {\n      value: \"E74\",\n      enumerable: false,\n      configurable: true\n    })));\n    // 2. Configure the cross-origin attribute before setting `src` in case the\n    //    browser begins to fetch.\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    // 3. Finally, set the source and inject into the DOM in case the child\n    //    must be appended for fetching to start.\n    script.src = src;\n    document.body.appendChild(script);\n  });\n}\n// We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\nlet devBuildPromise;\n// Resolve a promise that times out after given amount of milliseconds.\nfunction resolvePromiseWithTimeout(p, ms, err) {\n  return new Promise((resolve, reject) => {\n    let cancelled = false;\n    p.then(r => {\n      // Resolved, cancel the timeout\n      cancelled = true;\n      resolve(r);\n    }).catch(reject);\n    // We wrap these checks separately for better dead-code elimination in\n    // production bundles.\n    if (process.env.NODE_ENV === 'development') {\n      ;\n      (devBuildPromise || Promise.resolve()).then(() => {\n        (0, _requestidlecallback.requestIdleCallback)(() => setTimeout(() => {\n          if (!cancelled) {\n            reject(err);\n          }\n        }, ms));\n      });\n    }\n    if (process.env.NODE_ENV !== 'development') {\n      (0, _requestidlecallback.requestIdleCallback)(() => setTimeout(() => {\n        if (!cancelled) {\n          reject(err);\n        }\n      }, ms));\n    }\n  });\n}\nfunction getClientBuildManifest() {\n  if (self.__BUILD_MANIFEST) {\n    return Promise.resolve(self.__BUILD_MANIFEST);\n  }\n  const onBuildManifest = new Promise(resolve => {\n    // Mandatory because this is not concurrent safe:\n    const cb = self.__BUILD_MANIFEST_CB;\n    self.__BUILD_MANIFEST_CB = () => {\n      resolve(self.__BUILD_MANIFEST);\n      cb && cb();\n    };\n  });\n  return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(Object.defineProperty(new Error('Failed to load client build manifest'), \"__NEXT_ERROR_CODE\", {\n    value: \"E273\",\n    enumerable: false,\n    configurable: true\n  })));\n}\nfunction getFilesForRoute(assetPrefix, route) {\n  if (process.env.NODE_ENV === 'development') {\n    const scriptUrl = assetPrefix + '/_next/static/chunks/pages' + (0, _encodeuripath.encodeURIPath)((0, _getassetpathfromroute.default)(route, '.js')) + getAssetQueryString();\n    return Promise.resolve({\n      scripts: [(0, _trustedtypes.__unsafeCreateTrustedScriptURL)(scriptUrl)],\n      // Styles are handled by `style-loader` in development:\n      css: []\n    });\n  }\n  return getClientBuildManifest().then(manifest => {\n    if (!(route in manifest)) {\n      throw markAssetError(Object.defineProperty(new Error(\"Failed to lookup route: \" + route), \"__NEXT_ERROR_CODE\", {\n        value: \"E446\",\n        enumerable: false,\n        configurable: true\n      }));\n    }\n    const allFiles = manifest[route].map(entry => assetPrefix + '/_next/' + (0, _encodeuripath.encodeURIPath)(entry));\n    return {\n      scripts: allFiles.filter(v => v.endsWith('.js')).map(v => (0, _trustedtypes.__unsafeCreateTrustedScriptURL)(v) + getAssetQueryString()),\n      css: allFiles.filter(v => v.endsWith('.css')).map(v => v + getAssetQueryString())\n    };\n  });\n}\nfunction createRouteLoader(assetPrefix) {\n  const entrypoints = new Map();\n  const loadedScripts = new Map();\n  const styleSheets = new Map();\n  const routes = new Map();\n  function maybeExecuteScript(src) {\n    // With HMR we might need to \"reload\" scripts when they are\n    // disposed and readded. Executing scripts twice has no functional\n    // differences\n    if (process.env.NODE_ENV !== 'development') {\n      let prom = loadedScripts.get(src.toString());\n      if (prom) {\n        return prom;\n      }\n      // Skip executing script if it's already in the DOM:\n      if (document.querySelector('script[src^=\"' + src + '\"]')) {\n        return Promise.resolve();\n      }\n      loadedScripts.set(src.toString(), prom = appendScript(src));\n      return prom;\n    } else {\n      return appendScript(src);\n    }\n  }\n  function fetchStyleSheet(href) {\n    let prom = styleSheets.get(href);\n    if (prom) {\n      return prom;\n    }\n    styleSheets.set(href, prom = fetch(href, {\n      credentials: 'same-origin'\n    }).then(res => {\n      if (!res.ok) {\n        throw Object.defineProperty(new Error(\"Failed to load stylesheet: \" + href), \"__NEXT_ERROR_CODE\", {\n          value: \"E189\",\n          enumerable: false,\n          configurable: true\n        });\n      }\n      return res.text().then(text => ({\n        href: href,\n        content: text\n      }));\n    }).catch(err => {\n      throw markAssetError(err);\n    }));\n    return prom;\n  }\n  return {\n    whenEntrypoint(route) {\n      return withFuture(route, entrypoints);\n    },\n    onEntrypoint(route, execute) {\n      ;\n      (execute ? Promise.resolve().then(() => execute()).then(exports1 => ({\n        component: exports1 && exports1.default || exports1,\n        exports: exports1\n      }), err => ({\n        error: err\n      })) : Promise.resolve(undefined)).then(input => {\n        const old = entrypoints.get(route);\n        if (old && 'resolve' in old) {\n          if (input) {\n            entrypoints.set(route, input);\n            old.resolve(input);\n          }\n        } else {\n          if (input) {\n            entrypoints.set(route, input);\n          } else {\n            entrypoints.delete(route);\n          }\n          // when this entrypoint has been resolved before\n          // the route is outdated and we want to invalidate\n          // this cache entry\n          routes.delete(route);\n        }\n      });\n    },\n    loadRoute(route, prefetch) {\n      return withFuture(route, routes, () => {\n        let devBuildPromiseResolve;\n        if (process.env.NODE_ENV === 'development') {\n          devBuildPromise = new Promise(resolve => {\n            devBuildPromiseResolve = resolve;\n          });\n        }\n        return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then(param => {\n          let {\n            scripts,\n            css\n          } = param;\n          return Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);\n        }).then(res => {\n          return this.whenEntrypoint(route).then(entrypoint => ({\n            entrypoint,\n            styles: res[1]\n          }));\n        }), MS_MAX_IDLE_DELAY, markAssetError(Object.defineProperty(new Error(\"Route did not complete loading: \" + route), \"__NEXT_ERROR_CODE\", {\n          value: \"E12\",\n          enumerable: false,\n          configurable: true\n        }))).then(param => {\n          let {\n            entrypoint,\n            styles\n          } = param;\n          const res = Object.assign({\n            styles: styles\n          }, entrypoint);\n          return 'error' in entrypoint ? entrypoint : res;\n        }).catch(err => {\n          if (prefetch) {\n            // we don't want to cache errors during prefetch\n            throw err;\n          }\n          return {\n            error: err\n          };\n        }).finally(() => devBuildPromiseResolve == null ? void 0 : devBuildPromiseResolve());\n      });\n    },\n    prefetch(route) {\n      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n      // License: Apache 2.0\n      let cn;\n      if (cn = navigator.connection) {\n        // Don't prefetch if using 2G or if Save-Data is enabled.\n        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n      }\n      return getFilesForRoute(assetPrefix, route).then(output => Promise.all(canPrefetch ? output.scripts.map(script => prefetchViaDom(script.toString(), 'script')) : [])).then(() => {\n        (0, _requestidlecallback.requestIdleCallback)(() => this.loadRoute(route, true).catch(() => {}));\n      }).catch(\n      // swallow prefetch errors\n      () => {});\n    }\n  };\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}","map":{"version":3,"names":["createRouteLoader","getClientBuildManifest","isAssetError","markAssetError","MS_MAX_IDLE_DELAY","withFuture","key","map","generator","entry","get","future","Promise","resolve","resolver","prom","set","then","value","catch","err","delete","ASSET_LOAD_ERROR","Symbol","Object","defineProperty","hasPrefetch","link","document","createElement","window","MSInputMethodContext","documentMode","relList","supports","e","canPrefetch","getAssetQueryString","_deploymentid","getDeploymentIdQueryOrEmptyString","prefetchViaDom","href","as","reject","selector","querySelector","rel","crossOrigin","process","env","__NEXT_CROSS_ORIGIN","onload","onerror","Error","head","appendChild","appendScript","src","script","body","devBuildPromise","resolvePromiseWithTimeout","p","ms","cancelled","r","NODE_ENV","_requestidlecallback","requestIdleCallback","setTimeout","self","__BUILD_MANIFEST","onBuildManifest","cb","__BUILD_MANIFEST_CB","getFilesForRoute","assetPrefix","route","scriptUrl","_encodeuripath","encodeURIPath","_getassetpathfromroute","default","scripts","_trustedtypes","__unsafeCreateTrustedScriptURL","css","manifest","allFiles","filter","v","endsWith","entrypoints","Map","loadedScripts","styleSheets","routes","maybeExecuteScript","toString","fetchStyleSheet","fetch","credentials","res","ok","text","content","whenEntrypoint","onEntrypoint","execute","exports1","component","exports","error","undefined","input","old","loadRoute","prefetch","devBuildPromiseResolve","param","all","has","entrypoint","styles","assign","finally","cn","navigator","connection","saveData","test","effectiveType","output"],"sources":["C:\\Users\\богдан\\Desktop\\gobybus\\client\\node_modules\\next\\src\\client\\route-loader.ts"],"sourcesContent":["import type { ComponentType } from 'react'\nimport type { MiddlewareMatcher } from '../build/analysis/get-page-static-info'\nimport getAssetPathFromRoute from '../shared/lib/router/utils/get-asset-path-from-route'\nimport { __unsafeCreateTrustedScriptURL } from './trusted-types'\nimport { requestIdleCallback } from './request-idle-callback'\nimport { getDeploymentIdQueryOrEmptyString } from '../build/deployment-id'\nimport { encodeURIPath } from '../shared/lib/encode-uri-path'\n\n// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\nconst MS_MAX_IDLE_DELAY = 3800\n\ndeclare global {\n  interface Window {\n    __BUILD_MANIFEST?: Record<string, string[]>\n    __BUILD_MANIFEST_CB?: Function\n    __MIDDLEWARE_MATCHERS?: MiddlewareMatcher[]\n    __MIDDLEWARE_MANIFEST_CB?: Function\n    __REACT_LOADABLE_MANIFEST?: any\n    __DYNAMIC_CSS_MANIFEST?: any\n    __RSC_MANIFEST?: any\n    __RSC_SERVER_MANIFEST?: any\n    __NEXT_FONT_MANIFEST?: any\n    __SUBRESOURCE_INTEGRITY_MANIFEST?: string\n    __INTERCEPTION_ROUTE_REWRITE_MANIFEST?: string\n  }\n}\n\ninterface LoadedEntrypointSuccess {\n  component: ComponentType\n  exports: any\n}\ninterface LoadedEntrypointFailure {\n  error: unknown\n}\ntype RouteEntrypoint = LoadedEntrypointSuccess | LoadedEntrypointFailure\n\ninterface RouteStyleSheet {\n  href: string\n  content: string\n}\n\ninterface LoadedRouteSuccess extends LoadedEntrypointSuccess {\n  styles: RouteStyleSheet[]\n}\ninterface LoadedRouteFailure {\n  error: unknown\n}\ntype RouteLoaderEntry = LoadedRouteSuccess | LoadedRouteFailure\n\ninterface Future<V> {\n  resolve: (entrypoint: V) => void\n  future: Promise<V>\n}\nfunction withFuture<T extends object>(\n  key: string,\n  map: Map<string, Future<T> | T>,\n  generator?: () => Promise<T>\n): Promise<T> {\n  let entry = map.get(key)\n  if (entry) {\n    if ('future' in entry) {\n      return entry.future\n    }\n    return Promise.resolve(entry)\n  }\n  let resolver: (entrypoint: T) => void\n  const prom: Promise<T> = new Promise<T>((resolve) => {\n    resolver = resolve\n  })\n  map.set(key, { resolve: resolver!, future: prom })\n  return generator\n    ? generator()\n        .then((value) => {\n          resolver(value)\n          return value\n        })\n        .catch((err) => {\n          map.delete(key)\n          throw err\n        })\n    : prom\n}\n\nexport interface RouteLoader {\n  whenEntrypoint(route: string): Promise<RouteEntrypoint>\n  onEntrypoint(route: string, execute: () => unknown): void\n  loadRoute(route: string, prefetch?: boolean): Promise<RouteLoaderEntry>\n  prefetch(route: string): Promise<void>\n}\n\nconst ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR')\n// TODO: unexport\nexport function markAssetError(err: Error): Error {\n  return Object.defineProperty(err, ASSET_LOAD_ERROR, {})\n}\n\nexport function isAssetError(err?: Error): boolean | undefined {\n  return err && ASSET_LOAD_ERROR in err\n}\n\nfunction hasPrefetch(link?: HTMLLinkElement): boolean {\n  try {\n    link = document.createElement('link')\n    return (\n      // detect IE11 since it supports prefetch but isn't detected\n      // with relList.support\n      (!!window.MSInputMethodContext && !!(document as any).documentMode) ||\n      link.relList.supports('prefetch')\n    )\n  } catch {\n    return false\n  }\n}\n\nconst canPrefetch: boolean = hasPrefetch()\n\nconst getAssetQueryString = () => {\n  return getDeploymentIdQueryOrEmptyString()\n}\n\nfunction prefetchViaDom(\n  href: string,\n  as: string,\n  link?: HTMLLinkElement\n): Promise<any> {\n  return new Promise<void>((resolve, reject) => {\n    const selector = `\n      link[rel=\"prefetch\"][href^=\"${href}\"],\n      link[rel=\"preload\"][href^=\"${href}\"],\n      script[src^=\"${href}\"]`\n    if (document.querySelector(selector)) {\n      return resolve()\n    }\n\n    link = document.createElement('link')\n\n    // The order of property assignment here is intentional:\n    if (as) link!.as = as\n    link!.rel = `prefetch`\n    link!.crossOrigin = process.env.__NEXT_CROSS_ORIGIN!\n    link!.onload = resolve as any\n    link!.onerror = () =>\n      reject(markAssetError(new Error(`Failed to prefetch: ${href}`)))\n\n    // `href` should always be last:\n    link!.href = href\n\n    document.head.appendChild(link)\n  })\n}\n\nfunction appendScript(\n  src: TrustedScriptURL | string,\n  script?: HTMLScriptElement\n): Promise<unknown> {\n  return new Promise((resolve, reject) => {\n    script = document.createElement('script')\n\n    // The order of property assignment here is intentional.\n    // 1. Setup success/failure hooks in case the browser synchronously\n    //    executes when `src` is set.\n    script.onload = resolve\n    script.onerror = () =>\n      reject(markAssetError(new Error(`Failed to load script: ${src}`)))\n\n    // 2. Configure the cross-origin attribute before setting `src` in case the\n    //    browser begins to fetch.\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN!\n\n    // 3. Finally, set the source and inject into the DOM in case the child\n    //    must be appended for fetching to start.\n    script.src = src as string\n    document.body.appendChild(script)\n  })\n}\n\n// We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\nlet devBuildPromise: Promise<void> | undefined\n\n// Resolve a promise that times out after given amount of milliseconds.\nfunction resolvePromiseWithTimeout<T>(\n  p: Promise<T>,\n  ms: number,\n  err: Error\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    let cancelled = false\n\n    p.then((r) => {\n      // Resolved, cancel the timeout\n      cancelled = true\n      resolve(r)\n    }).catch(reject)\n\n    // We wrap these checks separately for better dead-code elimination in\n    // production bundles.\n    if (process.env.NODE_ENV === 'development') {\n      ;(devBuildPromise || Promise.resolve()).then(() => {\n        requestIdleCallback(() =>\n          setTimeout(() => {\n            if (!cancelled) {\n              reject(err)\n            }\n          }, ms)\n        )\n      })\n    }\n\n    if (process.env.NODE_ENV !== 'development') {\n      requestIdleCallback(() =>\n        setTimeout(() => {\n          if (!cancelled) {\n            reject(err)\n          }\n        }, ms)\n      )\n    }\n  })\n}\n\n// TODO: stop exporting or cache the failure\n// It'd be best to stop exporting this. It's an implementation detail. We're\n// only exporting it for backwards compatibility with the `page-loader`.\n// Only cache this response as a last resort if we cannot eliminate all other\n// code branches that use the Build Manifest Callback and push them through\n// the Route Loader interface.\nexport function getClientBuildManifest() {\n  if (self.__BUILD_MANIFEST) {\n    return Promise.resolve(self.__BUILD_MANIFEST)\n  }\n\n  const onBuildManifest = new Promise<Record<string, string[]>>((resolve) => {\n    // Mandatory because this is not concurrent safe:\n    const cb = self.__BUILD_MANIFEST_CB\n    self.__BUILD_MANIFEST_CB = () => {\n      resolve(self.__BUILD_MANIFEST!)\n      cb && cb()\n    }\n  })\n\n  return resolvePromiseWithTimeout(\n    onBuildManifest,\n    MS_MAX_IDLE_DELAY,\n    markAssetError(new Error('Failed to load client build manifest'))\n  )\n}\n\ninterface RouteFiles {\n  scripts: (TrustedScriptURL | string)[]\n  css: string[]\n}\nfunction getFilesForRoute(\n  assetPrefix: string,\n  route: string\n): Promise<RouteFiles> {\n  if (process.env.NODE_ENV === 'development') {\n    const scriptUrl =\n      assetPrefix +\n      '/_next/static/chunks/pages' +\n      encodeURIPath(getAssetPathFromRoute(route, '.js')) +\n      getAssetQueryString()\n    return Promise.resolve({\n      scripts: [__unsafeCreateTrustedScriptURL(scriptUrl)],\n      // Styles are handled by `style-loader` in development:\n      css: [],\n    })\n  }\n  return getClientBuildManifest().then((manifest) => {\n    if (!(route in manifest)) {\n      throw markAssetError(new Error(`Failed to lookup route: ${route}`))\n    }\n    const allFiles = manifest[route].map(\n      (entry) => assetPrefix + '/_next/' + encodeURIPath(entry)\n    )\n    return {\n      scripts: allFiles\n        .filter((v) => v.endsWith('.js'))\n        .map((v) => __unsafeCreateTrustedScriptURL(v) + getAssetQueryString()),\n      css: allFiles\n        .filter((v) => v.endsWith('.css'))\n        .map((v) => v + getAssetQueryString()),\n    }\n  })\n}\n\nexport function createRouteLoader(assetPrefix: string): RouteLoader {\n  const entrypoints: Map<string, Future<RouteEntrypoint> | RouteEntrypoint> =\n    new Map()\n  const loadedScripts: Map<string, Promise<unknown>> = new Map()\n  const styleSheets: Map<string, Promise<RouteStyleSheet>> = new Map()\n  const routes: Map<string, Future<RouteLoaderEntry> | RouteLoaderEntry> =\n    new Map()\n\n  function maybeExecuteScript(\n    src: TrustedScriptURL | string\n  ): Promise<unknown> {\n    // With HMR we might need to \"reload\" scripts when they are\n    // disposed and readded. Executing scripts twice has no functional\n    // differences\n    if (process.env.NODE_ENV !== 'development') {\n      let prom: Promise<unknown> | undefined = loadedScripts.get(src.toString())\n      if (prom) {\n        return prom\n      }\n\n      // Skip executing script if it's already in the DOM:\n      if (document.querySelector(`script[src^=\"${src}\"]`)) {\n        return Promise.resolve()\n      }\n\n      loadedScripts.set(src.toString(), (prom = appendScript(src)))\n      return prom\n    } else {\n      return appendScript(src)\n    }\n  }\n\n  function fetchStyleSheet(href: string): Promise<RouteStyleSheet> {\n    let prom: Promise<RouteStyleSheet> | undefined = styleSheets.get(href)\n    if (prom) {\n      return prom\n    }\n\n    styleSheets.set(\n      href,\n      (prom = fetch(href, { credentials: 'same-origin' })\n        .then((res) => {\n          if (!res.ok) {\n            throw new Error(`Failed to load stylesheet: ${href}`)\n          }\n          return res.text().then((text) => ({ href: href, content: text }))\n        })\n        .catch((err) => {\n          throw markAssetError(err)\n        }))\n    )\n    return prom\n  }\n\n  return {\n    whenEntrypoint(route: string) {\n      return withFuture(route, entrypoints)\n    },\n    onEntrypoint(route: string, execute: undefined | (() => unknown)) {\n      ;(execute\n        ? Promise.resolve()\n            .then(() => execute())\n            .then(\n              (exports: any) => ({\n                component: (exports && exports.default) || exports,\n                exports: exports,\n              }),\n              (err) => ({ error: err })\n            )\n        : Promise.resolve(undefined)\n      ).then((input: RouteEntrypoint | undefined) => {\n        const old = entrypoints.get(route)\n        if (old && 'resolve' in old) {\n          if (input) {\n            entrypoints.set(route, input)\n            old.resolve(input)\n          }\n        } else {\n          if (input) {\n            entrypoints.set(route, input)\n          } else {\n            entrypoints.delete(route)\n          }\n          // when this entrypoint has been resolved before\n          // the route is outdated and we want to invalidate\n          // this cache entry\n          routes.delete(route)\n        }\n      })\n    },\n    loadRoute(route: string, prefetch?: boolean) {\n      return withFuture<RouteLoaderEntry>(route, routes, () => {\n        let devBuildPromiseResolve: () => void\n\n        if (process.env.NODE_ENV === 'development') {\n          devBuildPromise = new Promise<void>((resolve) => {\n            devBuildPromiseResolve = resolve\n          })\n        }\n\n        return resolvePromiseWithTimeout(\n          getFilesForRoute(assetPrefix, route)\n            .then(({ scripts, css }) => {\n              return Promise.all([\n                entrypoints.has(route)\n                  ? []\n                  : Promise.all(scripts.map(maybeExecuteScript)),\n                Promise.all(css.map(fetchStyleSheet)),\n              ] as const)\n            })\n            .then((res) => {\n              return this.whenEntrypoint(route).then((entrypoint) => ({\n                entrypoint,\n                styles: res[1],\n              }))\n            }),\n          MS_MAX_IDLE_DELAY,\n          markAssetError(new Error(`Route did not complete loading: ${route}`))\n        )\n          .then(({ entrypoint, styles }) => {\n            const res: RouteLoaderEntry = Object.assign<\n              { styles: RouteStyleSheet[] },\n              RouteEntrypoint\n            >({ styles: styles! }, entrypoint)\n            return 'error' in entrypoint ? entrypoint : res\n          })\n          .catch((err) => {\n            if (prefetch) {\n              // we don't want to cache errors during prefetch\n              throw err\n            }\n            return { error: err }\n          })\n          .finally(() => devBuildPromiseResolve?.())\n      })\n    },\n    prefetch(route: string): Promise<void> {\n      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n      // License: Apache 2.0\n      let cn\n      if ((cn = (navigator as any).connection)) {\n        // Don't prefetch if using 2G or if Save-Data is enabled.\n        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve()\n      }\n      return getFilesForRoute(assetPrefix, route)\n        .then((output) =>\n          Promise.all(\n            canPrefetch\n              ? output.scripts.map((script) =>\n                  prefetchViaDom(script.toString(), 'script')\n                )\n              : []\n          )\n        )\n        .then(() => {\n          requestIdleCallback(() => this.loadRoute(route, true).catch(() => {}))\n        })\n        .catch(\n          // swallow prefetch errors\n          () => {}\n        )\n    },\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}