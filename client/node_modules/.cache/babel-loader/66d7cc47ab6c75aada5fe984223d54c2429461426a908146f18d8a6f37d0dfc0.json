{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"getNextPathnameInfo\", {\n  enumerable: true,\n  get: function () {\n    return getNextPathnameInfo;\n  }\n});\nconst _normalizelocalepath = require(\"../../i18n/normalize-locale-path\");\nconst _removepathprefix = require(\"./remove-path-prefix\");\nconst _pathhasprefix = require(\"./path-has-prefix\");\nfunction getNextPathnameInfo(pathname, options) {\n  var _options_nextConfig;\n  const {\n    basePath,\n    i18n,\n    trailingSlash\n  } = (_options_nextConfig = options.nextConfig) != null ? _options_nextConfig : {};\n  const info = {\n    pathname,\n    trailingSlash: pathname !== '/' ? pathname.endsWith('/') : trailingSlash\n  };\n  if (basePath && (0, _pathhasprefix.pathHasPrefix)(info.pathname, basePath)) {\n    info.pathname = (0, _removepathprefix.removePathPrefix)(info.pathname, basePath);\n    info.basePath = basePath;\n  }\n  let pathnameNoDataPrefix = info.pathname;\n  if (info.pathname.startsWith('/_next/data/') && info.pathname.endsWith('.json')) {\n    const paths = info.pathname.replace(/^\\/_next\\/data\\//, '').replace(/\\.json$/, '').split('/');\n    const buildId = paths[0];\n    info.buildId = buildId;\n    pathnameNoDataPrefix = paths[1] !== 'index' ? \"/\" + paths.slice(1).join('/') : '/';\n    // update pathname with normalized if enabled although\n    // we use normalized to populate locale info still\n    if (options.parseData === true) {\n      info.pathname = pathnameNoDataPrefix;\n    }\n  }\n  // If provided, use the locale route normalizer to detect the locale instead\n  // of the function below.\n  if (i18n) {\n    let result = options.i18nProvider ? options.i18nProvider.analyze(info.pathname) : (0, _normalizelocalepath.normalizeLocalePath)(info.pathname, i18n.locales);\n    info.locale = result.detectedLocale;\n    var _result_pathname;\n    info.pathname = (_result_pathname = result.pathname) != null ? _result_pathname : info.pathname;\n    if (!result.detectedLocale && info.buildId) {\n      result = options.i18nProvider ? options.i18nProvider.analyze(pathnameNoDataPrefix) : (0, _normalizelocalepath.normalizeLocalePath)(pathnameNoDataPrefix, i18n.locales);\n      if (result.detectedLocale) {\n        info.locale = result.detectedLocale;\n      }\n    }\n  }\n  return info;\n}","map":{"version":3,"names":["getNextPathnameInfo","pathname","options","_options_nextConfig","basePath","i18n","trailingSlash","nextConfig","info","endsWith","_pathhasprefix","pathHasPrefix","_removepathprefix","removePathPrefix","pathnameNoDataPrefix","startsWith","paths","replace","split","buildId","slice","join","parseData","result","i18nProvider","analyze","_normalizelocalepath","normalizeLocalePath","locales","locale","detectedLocale","_result_pathname"],"sources":["C:\\Users\\богдан\\Desktop\\gobybus\\client\\node_modules\\next\\src\\shared\\lib\\router\\utils\\get-next-pathname-info.ts"],"sourcesContent":["import { normalizeLocalePath } from '../../i18n/normalize-locale-path'\nimport { removePathPrefix } from './remove-path-prefix'\nimport { pathHasPrefix } from './path-has-prefix'\nimport type { I18NProvider } from '../../../../server/lib/i18n-provider'\n\nexport interface NextPathnameInfo {\n  /**\n   * The base path in case the pathname included it.\n   */\n  basePath?: string\n  /**\n   * The buildId for when the parsed URL is a data URL. Parsing it can be\n   * disabled with the `parseData` option.\n   */\n  buildId?: string\n  /**\n   * If there was a locale in the pathname, this will hold its value.\n   */\n  locale?: string\n  /**\n   * The processed pathname without a base path, locale, or data URL elements\n   * when parsing it is enabled.\n   */\n  pathname: string\n  /**\n   * A boolean telling if the pathname had a trailingSlash. This can be only\n   * true if trailingSlash is enabled.\n   */\n  trailingSlash?: boolean\n}\n\ninterface Options {\n  /**\n   * When passed to true, this function will also parse Nextjs data URLs.\n   */\n  parseData?: boolean\n  /**\n   * A partial of the Next.js configuration to parse the URL.\n   */\n  nextConfig?: {\n    basePath?: string\n    i18n?: { locales?: readonly string[] } | null\n    trailingSlash?: boolean\n  }\n\n  /**\n   * If provided, this normalizer will be used to detect the locale instead of\n   * the default locale detection.\n   */\n  i18nProvider?: I18NProvider\n}\n\nexport function getNextPathnameInfo(\n  pathname: string,\n  options: Options\n): NextPathnameInfo {\n  const { basePath, i18n, trailingSlash } = options.nextConfig ?? {}\n  const info: NextPathnameInfo = {\n    pathname,\n    trailingSlash: pathname !== '/' ? pathname.endsWith('/') : trailingSlash,\n  }\n\n  if (basePath && pathHasPrefix(info.pathname, basePath)) {\n    info.pathname = removePathPrefix(info.pathname, basePath)\n    info.basePath = basePath\n  }\n  let pathnameNoDataPrefix = info.pathname\n\n  if (\n    info.pathname.startsWith('/_next/data/') &&\n    info.pathname.endsWith('.json')\n  ) {\n    const paths = info.pathname\n      .replace(/^\\/_next\\/data\\//, '')\n      .replace(/\\.json$/, '')\n      .split('/')\n\n    const buildId = paths[0]\n    info.buildId = buildId\n    pathnameNoDataPrefix =\n      paths[1] !== 'index' ? `/${paths.slice(1).join('/')}` : '/'\n\n    // update pathname with normalized if enabled although\n    // we use normalized to populate locale info still\n    if (options.parseData === true) {\n      info.pathname = pathnameNoDataPrefix\n    }\n  }\n\n  // If provided, use the locale route normalizer to detect the locale instead\n  // of the function below.\n  if (i18n) {\n    let result = options.i18nProvider\n      ? options.i18nProvider.analyze(info.pathname)\n      : normalizeLocalePath(info.pathname, i18n.locales)\n\n    info.locale = result.detectedLocale\n    info.pathname = result.pathname ?? info.pathname\n\n    if (!result.detectedLocale && info.buildId) {\n      result = options.i18nProvider\n        ? options.i18nProvider.analyze(pathnameNoDataPrefix)\n        : normalizeLocalePath(pathnameNoDataPrefix, i18n.locales)\n\n      if (result.detectedLocale) {\n        info.locale = result.detectedLocale\n      }\n    }\n  }\n  return info\n}\n"],"mappings":";;;;;+BAoDgB;;;WAAAA,mBAAA;;;qCApDoB;kCACH;+BACH;AAkDvB,SAASA,oBACdC,QAAgB,EAChBC,OAAgB;MAE0BC,mBAAA;EAA1C,MAAM;IAAEC,QAAQ;IAAEC,IAAI;IAAEC;EAAa,CAAE,GAAG,CAAAH,mBAAA,GAAAD,OAAA,CAAQK,UAAU,YAAlBJ,mBAAA,GAAsB,CAAC;EACjE,MAAMK,IAAA,GAAyB;IAC7BP,QAAA;IACAK,aAAA,EAAeL,QAAA,KAAa,MAAMA,QAAA,CAASQ,QAAQ,CAAC,OAAOH;EAC7D;EAEA,IAAIF,QAAA,IAAY,IAAAM,cAAA,CAAAC,aAAa,EAACH,IAAA,CAAKP,QAAQ,EAAEG,QAAA,GAAW;IACtDI,IAAA,CAAKP,QAAQ,GAAG,IAAAW,iBAAA,CAAAC,gBAAgB,EAACL,IAAA,CAAKP,QAAQ,EAAEG,QAAA;IAChDI,IAAA,CAAKJ,QAAQ,GAAGA,QAAA;EAClB;EACA,IAAIU,oBAAA,GAAuBN,IAAA,CAAKP,QAAQ;EAExC,IACEO,IAAA,CAAKP,QAAQ,CAACc,UAAU,CAAC,mBACzBP,IAAA,CAAKP,QAAQ,CAACQ,QAAQ,CAAC,UACvB;IACA,MAAMO,KAAA,GAAQR,IAAA,CAAKP,QAAQ,CACxBgB,OAAO,CAAC,oBAAoB,IAC5BA,OAAO,CAAC,WAAW,IACnBC,KAAK,CAAC;IAET,MAAMC,OAAA,GAAUH,KAAK,CAAC,EAAE;IACxBR,IAAA,CAAKW,OAAO,GAAGA,OAAA;IACfL,oBAAA,GACEE,KAAK,CAAC,EAAE,KAAK,UAAU,GAAC,GAAGA,KAAA,CAAMI,KAAK,CAAC,GAAGC,IAAI,CAAC,OAAS;IAE1D;IACA;IACA,IAAInB,OAAA,CAAQoB,SAAS,KAAK,MAAM;MAC9Bd,IAAA,CAAKP,QAAQ,GAAGa,oBAAA;IAClB;EACF;EAEA;EACA;EACA,IAAIT,IAAA,EAAM;IACR,IAAIkB,MAAA,GAASrB,OAAA,CAAQsB,YAAY,GAC7BtB,OAAA,CAAQsB,YAAY,CAACC,OAAO,CAACjB,IAAA,CAAKP,QAAQ,IAC1C,IAAAyB,oBAAA,CAAAC,mBAAmB,EAACnB,IAAA,CAAKP,QAAQ,EAAEI,IAAA,CAAKuB,OAAO;IAEnDpB,IAAA,CAAKqB,MAAM,GAAGN,MAAA,CAAOO,cAAc;QACnBC,gBAAA;IAAhBvB,IAAA,CAAKP,QAAQ,GAAG,CAAA8B,gBAAA,GAAAR,MAAA,CAAOtB,QAAQ,YAAf8B,gBAAA,GAAmBvB,IAAA,CAAKP,QAAQ;IAEhD,IAAI,CAACsB,MAAA,CAAOO,cAAc,IAAItB,IAAA,CAAKW,OAAO,EAAE;MAC1CI,MAAA,GAASrB,OAAA,CAAQsB,YAAY,GACzBtB,OAAA,CAAQsB,YAAY,CAACC,OAAO,CAACX,oBAAA,IAC7B,IAAAY,oBAAA,CAAAC,mBAAmB,EAACb,oBAAA,EAAsBT,IAAA,CAAKuB,OAAO;MAE1D,IAAIL,MAAA,CAAOO,cAAc,EAAE;QACzBtB,IAAA,CAAKqB,MAAM,GAAGN,MAAA,CAAOO,cAAc;MACrC;IACF;EACF;EACA,OAAOtB,IAAA;AACT","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}