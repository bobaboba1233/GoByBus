{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"getPathMatch\", {\n  enumerable: true,\n  get: function () {\n    return getPathMatch;\n  }\n});\nconst _pathtoregexp = require(\"next/dist/compiled/path-to-regexp\");\nfunction getPathMatch(path, options) {\n  const keys = [];\n  const regexp = (0, _pathtoregexp.pathToRegexp)(path, keys, {\n    delimiter: '/',\n    sensitive: typeof (options == null ? void 0 : options.sensitive) === 'boolean' ? options.sensitive : false,\n    strict: options == null ? void 0 : options.strict\n  });\n  const matcher = (0, _pathtoregexp.regexpToFunction)((options == null ? void 0 : options.regexModifier) ? new RegExp(options.regexModifier(regexp.source), regexp.flags) : regexp, keys);\n  /**\n  * A matcher function that will check if a given pathname matches the path\n  * given in the builder function. When the path does not match it will return\n  * `false` but if it does it will return an object with the matched params\n  * merged with the params provided in the second argument.\n  */\n  return (pathname, params) => {\n    // If no pathname is provided it's not a match.\n    if (typeof pathname !== 'string') return false;\n    const match = matcher(pathname);\n    // If the path did not match `false` will be returned.\n    if (!match) return false;\n    /**\n    * If unnamed params are not allowed they must be removed from\n    * the matched parameters. path-to-regexp uses \"string\" for named and\n    * \"number\" for unnamed parameters.\n    */\n    if (options == null ? void 0 : options.removeUnnamedParams) {\n      for (const key of keys) {\n        if (typeof key.name === 'number') {\n          delete match.params[key.name];\n        }\n      }\n    }\n    return {\n      ...params,\n      ...match.params\n    };\n  };\n}","map":{"version":3,"names":["getPathMatch","path","options","keys","regexp","_pathtoregexp","pathToRegexp","delimiter","sensitive","strict","matcher","regexpToFunction","regexModifier","RegExp","source","flags","pathname","params","match","removeUnnamedParams","key","name"],"sources":["C:\\Users\\богдан\\Desktop\\gobybus\\client\\node_modules\\next\\src\\shared\\lib\\router\\utils\\path-match.ts"],"sourcesContent":["import type { Key } from 'next/dist/compiled/path-to-regexp'\nimport { pathToRegexp } from 'next/dist/compiled/path-to-regexp'\nimport { regexpToFunction } from 'next/dist/compiled/path-to-regexp'\n\ninterface Options {\n  /**\n   * A transformer function that will be applied to the regexp generated\n   * from the provided path and path-to-regexp.\n   */\n  regexModifier?: (regex: string) => string\n  /**\n   * When true the function will remove all unnamed parameters\n   * from the matched parameters.\n   */\n  removeUnnamedParams?: boolean\n  /**\n   * When true the regexp won't allow an optional trailing delimiter\n   * to match.\n   */\n  strict?: boolean\n\n  /**\n   * When true the matcher will be case-sensitive, defaults to false\n   */\n  sensitive?: boolean\n}\n\nexport type PatchMatcher = (\n  pathname: string,\n  params?: Record<string, any>\n) => Record<string, any> | false\n\n/**\n * Generates a path matcher function for a given path and options based on\n * path-to-regexp. By default the match will be case insensitive, non strict\n * and delimited by `/`.\n */\nexport function getPathMatch(path: string, options?: Options): PatchMatcher {\n  const keys: Key[] = []\n  const regexp = pathToRegexp(path, keys, {\n    delimiter: '/',\n    sensitive:\n      typeof options?.sensitive === 'boolean' ? options.sensitive : false,\n    strict: options?.strict,\n  })\n\n  const matcher = regexpToFunction<Record<string, any>>(\n    options?.regexModifier\n      ? new RegExp(options.regexModifier(regexp.source), regexp.flags)\n      : regexp,\n    keys\n  )\n\n  /**\n   * A matcher function that will check if a given pathname matches the path\n   * given in the builder function. When the path does not match it will return\n   * `false` but if it does it will return an object with the matched params\n   * merged with the params provided in the second argument.\n   */\n  return (pathname, params) => {\n    // If no pathname is provided it's not a match.\n    if (typeof pathname !== 'string') return false\n\n    const match = matcher(pathname)\n\n    // If the path did not match `false` will be returned.\n    if (!match) return false\n\n    /**\n     * If unnamed params are not allowed they must be removed from\n     * the matched parameters. path-to-regexp uses \"string\" for named and\n     * \"number\" for unnamed parameters.\n     */\n    if (options?.removeUnnamedParams) {\n      for (const key of keys) {\n        if (typeof key.name === 'number') {\n          delete match.params[key.name]\n        }\n      }\n    }\n\n    return { ...params, ...match.params }\n  }\n}\n"],"mappings":";;;;;+BAqCgB;;;WAAAA,YAAA;;;8BApCa;AAoCtB,SAASA,aAAaC,IAAY,EAAEC,OAAiB;EAC1D,MAAMC,IAAA,GAAc,EAAE;EACtB,MAAMC,MAAA,GAAS,IAAAC,aAAA,CAAAC,YAAY,EAACL,IAAA,EAAME,IAAA,EAAM;IACtCI,SAAA,EAAW;IACXC,SAAA,EACE,QAAON,OAAA,oBAAAA,OAAA,CAASM,SAAS,MAAK,YAAYN,OAAA,CAAQM,SAAS,GAAG;IAChEC,MAAM,EAAEP,OAAA,oBAAAA,OAAA,CAASO;EACnB;EAEA,MAAMC,OAAA,GAAU,IAAAL,aAAA,CAAAM,gBAAgB,EAC9B,CAAAT,OAAA,oBAAAA,OAAA,CAASU,aAAa,IAClB,IAAIC,MAAA,CAAOX,OAAA,CAAQU,aAAa,CAACR,MAAA,CAAOU,MAAM,GAAGV,MAAA,CAAOW,KAAK,IAC7DX,MAAA,EACJD,IAAA;EAGF;;;;;;EAMA,OAAO,CAACa,QAAA,EAAUC,MAAA;IAChB;IACA,IAAI,OAAOD,QAAA,KAAa,UAAU,OAAO;IAEzC,MAAME,KAAA,GAAQR,OAAA,CAAQM,QAAA;IAEtB;IACA,IAAI,CAACE,KAAA,EAAO,OAAO;IAEnB;;;;;IAKA,IAAIhB,OAAA,oBAAAA,OAAA,CAASiB,mBAAmB,EAAE;MAChC,KAAK,MAAMC,GAAA,IAAOjB,IAAA,EAAM;QACtB,IAAI,OAAOiB,GAAA,CAAIC,IAAI,KAAK,UAAU;UAChC,OAAOH,KAAA,CAAMD,MAAM,CAACG,GAAA,CAAIC,IAAI,CAAC;QAC/B;MACF;IACF;IAEA,OAAO;MAAE,GAAGJ,MAAM;MAAE,GAAGC,KAAA,CAAMD;IAAO;EACtC;AACF","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}